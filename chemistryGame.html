
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src="atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
		<div id="startG" class= "firstpopup">
			<p style= "font: bold 20px Calibri"> Welcome to the laboratory! </p>
			<p id = "startTextofGame" style = "font: 15px Calibri"></p>
			<input type= "image" src = "images/start.png" id= "startButton" onclick ="startG()">
		</div>
		<div id="wrongAnswer" class = "popup" >
			<div class = "popup-content">
				<p id = "textAnswer" style ="font: 12px Verdana" ></p>
				<!--'<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">-->
			</div	>
		</div>

		<div id= "gamedone" class = "popup">
			<div class = "popup-content">
				<p id = "finishText" style="font: 15px arial;"></p>
			</div>
		</div>

		<div id= "totalScore" class= "lastpopup">
			<div class = "popup-content">
				<p id = "score" style="font: 15px arial;"></p>
			</div>
		</div>

		<div class = "progressText">
			<div class = "textProgresscontent">
				<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Current Salary</p>
			</div>
		</div>

		<div class = "atomButtons">
			<div class = "textProgresscontent">
				<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Atom creators</p>
			</div>
		</div>

		<div class = "progress">
			<div id="myProgress">
		  	<div id="myBar"></div>
			</div>
		</div>

		<div class = "amountSalary">
			<div class = "SalaryContent">
				<p id="salarytext" style="font: bold 25px times new roman; color: green;"></p>
			</div>
		</div>

	<div id= "missionTextPopup" class = "missionPopup">
		<div class = "mission-content">
			<p id = "missionText"></p>
		</div>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render});

var popup = document.getElementById('wrongAnswer');
var finish = document.getElementById('gamedone');
var last = document.getElementById('totalScore');
var firstpopup = document.getElementById('startG');
var missionpopup = document.getElementById('missionTextPopup');
var bar = document.getElementById("myBar");

bar.style.height = "85%";

var currentQuestion = new Trial(game);
var id = 0;
var height = 90;

var listOfQuestions = [];
var priorityQueueQuestions = [];
var text = [];
var feedbackText = [];
var buttonsList = [];

var buttons = ['HButton', 'CButton', 'OButton', 'QButton', 'FButton', 'IButton', 'ZButton'];
var positionY = [75, 125, 175, 225, 275, 325, 375];
var atomValues = ['H', 'C', 'O', 'Q', 'F', 'I', 'Z'];
var covalences = [1,4,2,1,1,1,1,1];
var gameIsFinished = false;
var randomStrategy = false;
var giveHints = false;
var evaluateAnswer = false;

var floor;
var doneButton;
var deleteButton;
var nextQuestion;
var next;
var restart;

var totalScore = 15; // van 0 tot 100. 0 is niks 100 is alles.

function preload() {
		game.load.image('CButton', 'images/CAtoomButtonGreen.png');
		game.load.image('OButton', 'images/OAtoomButtonGreen.png');
		game.load.image('HButton', 'images/HAtoomButtonGreen.png');
		game.load.image("FButton", 'images/FAtoomButtonGreen.png');
		game.load.image("QButton", 'images/BrAtoomButtonGreen.png');
		game.load.image("IButton", 'images/IAtoomButtonGreen.png');
		game.load.image("ZButton", "images/ClAtoomButtonGreen.png");
		game.load.image("Z", "images/ClAtomCircle.png");
		game.load.image('delete', 'images/garbage.png');
		game.load.image('C', 'images/CAtomCircle.png');
		game.load.image('H', 'images/HAtomCircle.png');
		game.load.image('O', 'images/OAtomCircle.png');
		game.load.image('I', 'images/IAtomCircle.png');
		game.load.image('Q', 'images/BrAtomCircle.png');
		game.load.image('F', 'images/FAtomCircle.png');
		game.load.image('done', 'images/doneButton2.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion.png');
		game.load.image('next', 'images/next.png');
		game.load.image('start', 'images/start.png');
		game.load.image('finish', 'images/finish.png');
		game.load.text('questions', 'questions.txt');
}

function create(){
	console.log("Hallo ik ben hier iets aan het typen!");
	var graphics1 = game.add.graphics(0, 0);
	var graphics2 = game.add.graphics(0, 0);
	var whiterect = game.add.graphics(0, 0);

	graphics1.beginFill(0xffdd99);
	graphics2.beginFill(0xAAAAAA);
	whiterect.beginFill(0xe6f2ff);

	graphics1.drawRect(10, 10, 80, 480); //3

	graphics1.drawRect(10, 500, 80, 90); //4

	graphics1.drawRect(100, 500, 575, 90); //5

	graphics1.drawRect(685, 500, 105, 90); //6

	graphics1.drawRect(685, 10, 105, 480); //7

	whiterect.drawRect(100,10, 575, 480); //2
	updateSalary();
	makeStartPopup();
	readQuestion();
	makePriorityQueue();
	currentQuestion = decideQuestion();

	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		//console.log("Klaar");
	}
	game.stage.backgroundColor = "#DBB782";
	// Make buttons
	doneButton = game.add.button(675, 505, 'done', evaluateAnswer3, this);
	nextQuestion = game.add.button(680, 500, 'nextQuestion', showNextQuestion, this);
	deleteButton = game.add.image(9, 500, 'delete');
	next = game.add.button(675, 500, 'next', showTotalScore, this);

	deleteButton.scale.setTo(0.4, 0.4);
	doneButton.visible = false;
	deleteButton.visible = false;
	nextQuestion.visible = false;
	next.visible = false;

	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = false;
	}
}

function makeButtons(){
	for(var i=0; i< buttons.length; i++){
		console.log(atomValues[i]);
		var buttonTest = new button(buttons[i], atomValues[i], 30, positionY[i]);
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0 && !currentQuestion.alreadyAdded){
			priorityQueueQuestions[0].isAsked = true;
			changeCovalence(priorityQueueQuestions[0]);
			priorityQueueQuestions[0].determineCovalence();
			return priorityQueueQuestions[0];
		}
		return decideAdaptively();
	}
}

function render () {
    game.debug.geom(floor,'#ffffff');
}

function makeStartPopup(){
	var startTextofGame = document.getElementById('startTextofGame');
	if(!randomStrategy){
	startTextofGame.innerText =
		"When you click on Start you are asked to complete some important assignments! \n" +
		"Try to complete as many assignments as you can and become rich (and save the world)!\n \n The bar on the right gives you an indication of how much money you are currently earning. " +
		"The panel on the left will show some elements that you could use to make molecules. If you click on one of these elements, one atom will appear on the screen. " +
		"You will be able to drag these atoms around and connect them together. They will become grey when connected. \n" +
		"If you are in need, your assistent will show up and help you! \n \n"  +
		"Your assistent can help you in various ways. When atoms suddenly become dark green or red, it means that your assistent is helping you with the connections. " +
		"Red means that the atom should be connected with less other atoms, dark green means that the atom is connected with the correct amount of atoms and light green means that an atom is connected and could be connected to more atoms. " +
		"Other types of help will become clear in the game itself! \n \n" +
		"We need you! Do not disappoint us! Good luck."
	}
	else{
		startTextofGame.innerText =
		"When you click on Start you are asked to complete some important assignments! \n" +
		"Try to complete as many assignments as you can and become rich (and save the world)!\n \n The bar on the right gives you an indication of how much money you are currently earning. " +
		"The panel on the left will show some elements that you could use to make molecules. If you click on one of these elements, one atom will appear on the screen. " +
		"You will be able to drag these atoms around and connect them together. They will become grey when connected. \n \n " +
		"We need you! Do not disappoint us! Good luck."
	}
}

function startG(){
	firstpopup.style.display = 'none';
	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = true;
	}
	deleteButton.visible = true;
	doneButton.visible = true;
	//console.log('start');
}

function determineOveralDifficulty(){
	var sum = 0;
	for(var i=0; i < listOfQuestions.length; i++){
		sum = sum + listOfQuestions[i].difficulty;
	}
	return sum;
}

function updateBar() {
	var SPEED = 1;
	var MINIMUM_EPSILON = 1;

	var elem = document.getElementById("myBar");
	var goalHeight = 100 - this.totalScore;
	var id = setInterval(frame, 20);

	function frame() {
		var currentHeight = parseInt(elem.style.height);
		var epsilon = goalHeight - currentHeight;
		if (Math.abs(epsilon) < MINIMUM_EPSILON)
			clearInterval(id);
		var newHeight = currentHeight + SPEED * Math.sign(epsilon)
		elem.style.height = newHeight + '%';
	}
}

function updateBarColor(){
	var elem = document.getElementById("myProgress");
	if(totalScore <= 15){
		elem.style.backgroundColor = "red";
	}
	else if(totalScore <= 30 && totalScore > 15){
		elem.style.backgroundColor = "orange";
	}
	else if(totalScore <= 50 && totalScore > 30){
		elem.style.backgroundColor = "yellow";
	}
	else if(totalScore <= 65 && totalScore > 50){
		elem.style.backgroundColor = "#ccff66";
	}
	else{
		elem.style.backgroundColor = "#669900";
	}
}

function updateSalary(){
	var salarytext = document.getElementById('salarytext');
	var roundScore = 60 * Math.round(totalScore);
	if(roundScore == 1){
		salarytext.innerText = "$ " + 1;
	}
	else{
		salarytext.innerText = "$ " + roundScore;
	}
}

function deleteAtom(){
	//console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 90 && this.sprite.x > 10 && this.sprite.y > 500 && this.sprite.y < 590){
		//console.log(this.sprite.x + " " + this.sprite.y);
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			//console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function makePriorityQueue(){
	var priority = [];
	for(var i=0; i<listOfQuestions.length; i++){
		priority.push(listOfQuestions[i].difficulty);
	}
	priority = priority.sort(function(a,b){
		return (+a) - (+b);
	});
	for(var i=0; i<priority.length; i++){
		for(var j=0; j<listOfQuestions.length; j++){
			if(priority[i] == listOfQuestions[j].difficulty && !priorityQueueQuestions.includes(listOfQuestions[j])){
				this.priorityQueueQuestions.push(listOfQuestions[j]);
				//console.log(listOfQuestions[j].currentQuestionText + " ");
			}
		}
	}
}

function pickRandomQuestion(){
	if(!allQuestionsAreAsked()){
		if(currentQuestion.repeat > 0 && currentQuestion.molecule.length != 0){
			currentQuestion.repeat -= 1;
			return currentQuestion;
		}
		else{
			// hier loopt hij vast.
			var x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
			while(priorityQueueQuestions[x].isAsked == true || priorityQueueQuestions[x].repeat != -1){
				x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
			}
			priorityQueueQuestions[x].isAsked = true;
			return priorityQueueQuestions[x];
		}
	}
	else{
		showLastPopup();
	}
}

function decideAdaptively(){
	decideOrderQuestions();
	for(var i=0; i< priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false || priorityQueueQuestions[i].repeat >= 1){
			priorityQueueQuestions[i].isAsked = true;
			if(priorityQueueQuestions[i].repeat > 0){
				priorityQueueQuestions[i].repeat -= 1;
			}
			return priorityQueueQuestions[i];
		}
	}
}

function decideOrderQuestions(){
// de waardes moeten nog aangepast worden, het moet ook zo zijn dat ze worden herhaald als de vragen weer wat moeilijker worden, nog even naar kijken.

	for(var i=0; i < priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == -1){
			var position = Math.min(priorityQueueQuestions.length, i+3);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			//console.log(priorityQueueQuestions[position]);
			return;
		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == -0.75){
			var position = Math.min(priorityQueueQuestions.length, i+4);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			//console.log(priorityQueueQuestions[position]);
			return;

		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == 0.5){
			var position = Math.min(priorityQueueQuestions.length, i+5);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			//console.log(priorityQueueQuestions[position]);
			return;

		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == 0.25){
			var position = Math.min(priorityQueueQuestions.length, i+6);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			//console.log(priorityQueueQuestions[position]);
			return;
		}
	 }
}

function determineText(){
	if(totalScore < 55){
		return 'Your salary is not that high, perhaps you should take a second job.';
	}
	else if(totalScore < 70 && totalScore > 55){
		return 'Great job!';
	}
	else{
		return 'Excellent. You\'ve become rich!';
	}
}

// hier nog even naar kijken!
function showTotalScore(){
	deleteSprites();
	next.visible = false;
	last.style.display = 'block';
	var lastPop = document.getElementById('score');
	finish.style.display = 'none';
	var endText = determineText();
	lastPop.innerText = "Your final salary is " + 60* Math.floor(totalScore) + " euros. " + endText;
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	if(text.indexOf('incorrect') > -1){
		gameDone.style.color = 'red';
	}
	gameDone.innerText = text;
	finish.style.display = 'block';
	next.visible = true;
}

function restartGame(){
	for(var i=0; i < priorityQueueQuestions.length; i++){
		priorityQueueQuestions[i].isAsked = false;
		priorityQueueQuestions[i].repeat = -1;
		priorityQueueQuestions[i].score = 0;
	}
	if(!randomStrategy){
		currentQuestion.finishGame();
	}
	totalScore = 10;
	updateBar();
	updateSalary();
	showNextQuestion();
}

function finishGame(){
	deleteSprites();
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
}

function getScore(){
	var sum = 0;
	for(var i=0; i < priorityQueueQuestions.length; i++){
			sum += priorityQueueQuestions[i].score;
	}
	return sum/priorityQueueQuestions.length * 10;
}

function allQuestionsAreAsked(){
	//console.log(priorityQueueQuestions.length);
	for(var i=0; i<priorityQueueQuestions.length; i++){
		//console.log(priorityQueueQuestions[i].moleculeName, priorityQueueQuestions[i].repeat);
		if(priorityQueueQuestions[i].isAsked == false || priorityQueueQuestions[i].repeat > 0){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Name') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.moleculeName = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				var atom = new Atom(atomsOfMolecule[j], false, id+j, game);
				trial.molecule.push(atom);
				trial.copyMolecule.push(atom);
			}
		}
		else if(textsQuestion[i].indexOf('Familiarity') > -1){
			var familiarity = textsQuestion[i].split(/~/);
			trial.familiarity = familiarity[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
						trial.copyMolecule[k].addConnection(trial.copyMolecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			trial.determineDifficulty();
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	//console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			//console.log("You are going to make a new question now!");
			makeTrial(new Trial(game), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	evaluateAnswer = false;
	deleteSprites();
	nextQuestion.visible = false;
	doneButton.visible = true;
	var textAnswer = document.getElementById('textAnswer');
	textAnswer.style.color = "black";
	popup.style.display = 'none';
	missionpopup.style.display = 'block';
	currentQuestion = decideQuestion(priorityQueueQuestions);
	if(currentQuestion != null){
		changeCovalence(currentQuestion);
		currentQuestion.determineCovalence();
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function changeCovalence(question){
	//console.log(question.moleculeName);
	if(question.moleculeName == 'Carbondioxide'){
		covalences = [1,2,1,1,1,1,1,1];;
	}
	else if(question.moleculeName == "Oxygen"){
		covalences = [1,4,1,1,1,1,1,1];;
	}
	else{
		covalences = [1,4,2,1,1,1,1,1];
	}
}

function evaluateAnswer3(){
	evaluateAnswer = true;
	var tooMany = false;
	var rightAmount = currentQuestion.checkAmountOfAtoms();
	// moet deze niet ook true opleveren als je wel de goede gebruikt?
	var rightUnique = currentQuestion.checkUniqueAtoms();
	var someRightUnique = currentQuestion.checkSomeUnique();
	var rightType = currentQuestion.checkAmountOfTypeOfAtoms();
	// rightconnections doet het nog niet helemaal goed lijkt het.
	var rightConnections = currentQuestion.checkConnections2();

	if(!rightAmount){
		var amountMolecule = currentQuestion.molecule.length;
		var amountCurrent = currentQuestion.currentMolecule.length;
		var getal = amountMolecule - amountCurrent;
		if(getal < 0){
			tooMany = true;
		}
		else{
			tooMany = false;
		}
	}
	console.log(rightAmount, rightType, rightUnique, rightConnections);
	determineScore(rightType, rightConnections, rightAmount, rightUnique, someRightUnique, tooMany);
}

function determineScore(rightType, rightConnections, rightAmount, rightUnique, someRightUnique, tooMany){
	if(!gameIsFinished){
		if(rightType && rightConnections && rightAmount && rightUnique){
			currentQuestion.repeat = 0;
			setProgress('Great Job!', 1, 'black');
		}
		else if(rightType && !rightConnections && rightAmount && rightUnique){
			setProgress('Almost correct! You do not have the right connections between atoms.', 0.5, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.4;
				currentQuestion.repeat = 1;
			}
			if(!randomStrategy){
				currentQuestion.hintConnections = true;
				currentQuestion.helpText = "Your assistent is going to help you with the connections."
			}
		}
		else if(!rightAmount && rightConnections){
			if(tooMany){
				setProgress('Your answer is incorrect. You have too many atoms, but you are almost there! You are still earning some money!', 0.25, 'red');
			}
			else{
				setProgress('Your answer is incorrect. You need to use more atoms, but you are almost there!', 0.25, 'red');
			}
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.20;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
			if(!rightUnique && !randomStrategy){
				currentQuestion.uniqueButtons = true;
			}
		}
		else if(!rightType && rightConnections && rightUnique){
			setProgress('Your answer is incorrect. You have the right connections but you are still missing some atoms.', 0.25, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore == 0.20;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
		}
		else if(!rightAmount && !rightUnique){
			// het kan zijn dat er wel 1 atoom bij zat die er in moet zitten, dus de tekst klopt hier niet helemaal. Nog aanpassen
			if(currentQuestion.currentMolecule.length != 0){
				if(someRightUnique){
					setProgress('Your answer is incorrect. You do not have the right amount of atoms. You need to have other types of elements or you have types that are not necessary.', -1, 'red');
				}
				else{
					setProgress('Your answer is incorrect. You do not have the right amount of atoms. You should also consider different elements.', -1, 'red');
				}
			}
			else{
				setProgress('Your answer is incorrect. Please try next time! Nothing ventured, nothing gained.', -1, 'red');
			}

			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.2;
				currentQuestion.repeat = 3;
				console.log(currentQuestion.maxScore);
			}
			if(!randomStrategy){
				currentQuestion.uniqueButtons = true;
				currentQuestion.helpNumber = true;
				currentQuestion.helpText = "Your assistent thinks you need to use these elements. You are also not able to make more elements than necessary.";
			}
		}
		else if(rightUnique && rightAmount){
			setProgress('Your answer is incorrect. You do use the right type of atoms. You, however, do not have the right amount of each element.', 0.25, 'red');
			if(currentQuestion.repeat = -1){
				currentQuestion.maxScore = 0.2;
				currentQuestion.repeat = 2;
			}
		}
		else if(rightUnique){
			// kan ook zijn dat je er te veel hebt.
			if(tooMany){
				setProgress('Your answer is incorrect. You do use the right atoms, but you have too many of them.', 0.25, 'red');
			}
			else{
				setProgress('Your answer is incorrect. You do use the right atoms, but you are still missing atoms.', 0.25, 'red');
			}
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.25;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
		}
		else if(rightAmount){
			if(someRightUnique){
				setProgress('Your answer is incorrect. You have the right amount of atoms, but you do not use all the right element types.', -0.75, 'red');
			}
			else{
				setProgress('Your answer is incorrect. The amount of atoms needed for this assignment is correct, however you should use different elements.', -0.75, 'red');
			}
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.25;
				currentQuestion.repeat = 3;
				console.log(currentQuestion.maxScore);
			}
			if(!randomStrategy){
				currentQuestion.uniqueButtons = true;
				currentQuestion.helpText = "Your assistent thinks you need to use these elements.";
			}
		}
	}
}

function setProgress(feedback, score, colour){
	//console.log(currentQuestion.maxScore);
	console.log("Deze score had je eerst" + totalScore);
	totalScore += convertScoreChange(score*currentQuestion.maxScore);
	console.log("Dit is de totale score: " + totalScore);
	totalScore = Math.max(0,totalScore);
	updateBar();
	updateBarColor();
	updateSalary();
	currentQuestion.score = score;

	if(allQuestionsAreAsked()){
		//console.log("hallo");
		doneButton.visible = false;
		nextQuestion.visible = false;
		popup.style.display = 'none';
		missionpopup.style.display = 'none';
		showLastPopup(feedback);
	}
	else{
		var textAnswer = document.getElementById('textAnswer');
		textAnswer.style.color = colour;
		textAnswer.innerText =  feedback;
		doneButton.visible = false;
		nextQuestion.visible = true;
		popup.style.display = 'block';
		missionpopup.style.display = 'none';
	}
}

function deleteSprites(){
	//console.log(currentQuestion.copyMolecule.length);
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		currentQuestion.currentMolecule[i].sprite.destroy();
	}
	currentQuestion.currentMolecule = [];
}

function addWrongQuestion(){
	var currentLength = priorityQueueQuestions.length;
	for(var i=0; i < currentQuestion.repeat; i++){
		if(!currentQuestion.alreadyAdded){
			priorityQueueQuestions.push(currentQuestion);
			//console.log(currentQuestion);
		}
	}
	if(currentLength != priorityQueueQuestions.length){
		currentQuestion.alreadyAdded = true;
		//console.log("deze ga ik niet adden");
	}
	//console.log(priorityQueueQuestions.length);
}

function printMolecule(){
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		console.log("Dit is Atom nummer " +  i + ", " + currentQuestion.currentMolecule[i].value + ", " + currentQuestion.currentMolecule[i].id);
		console.log(currentQuestion.currentMolecule[i]);
	}
}

function convertScoreChange(answerScore) {
	var totalDifficulty = determineOveralDifficulty();
	return answerScore * 85 * currentQuestion.difficulty / totalDifficulty;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    if(currentQuestion.helpNumber){
			if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element) && !gameIsFinished){
	  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
	  		var atomNew = new Atom(element, true, id, game);
				atomNew.covalence = atomNew.determineCovalence();
	  		currentQuestion.currentMolecule.push(atomNew);
				id = id+1;
	  	}
		}
		else{
			var atomNew = new Atom(element, true, id, game);
			atomNew.covalence = atomNew.determineCovalence();
			currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
		}
  }
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
	game.world.bringToTop(button);
	buttonsList.push(button);
  button.scale.setTo(0.3, 0.3);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
					currentMolecule[i].determineTint();
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
		currentMolecule[i].determineTint();
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		//console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
