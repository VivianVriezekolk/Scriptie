
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src="atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
		<div id="startG" class= "firstpopup">
			<p id = "startTextofGame"></p>
			<input type= "image" src = "images/start.png" id= "startButton" onclick ="startG()">
		</div>
		<div id="wrongAnswer" class = "popup" >
			<div class = "popup-content">
				<p id = "textAnswer"></p>
				<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">
			</div	>
		</div>
		<div id= "gamedone" class = "popup">
			<div class = "popup-content">
				<p id = "finishText"></p>
				<p id = "score"></p>
				<input type= "image" src = "images/finish.png" id= "Okbutton" onclick ="finishGame()">
				<input type= "image" src = "images/restart.png" id= "Okbutton" onclick ="restartGame()">
			</div>
		</div>
		<div class = "progressText">
			<div class = "textProgresscontent">
			<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Current Salary</p>
		</div>
		</div>
		<div class = "progress">
		<div id="myProgress">
	  	<div id="myBar"></div></div>
		</div>
		<div class = "amountSalary">
			<div class = "SalaryContent">
			<p id="salarytext" style="font: 15px times new roman; color: green;"></p>
		</div>
		</div>
	<div id= "missionTextPopup" class = "missionPopup">
		<div class = "mission-content">
			<p id = "missionText"></p>
		</div>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render});
var currentQuestion = new Trial(game, group);
var id = 0;
var listOfQuestions = [];
var priorityQueueQuestions = [];
var text = [];
var feedbackText = [];
var popup = document.getElementById('wrongAnswer');
var finish = document.getElementById('gamedone');
var firstpopup = document.getElementById('startG');
var missionpopup = document.getElementById('missionTextPopup');
var gameIsFinished = false;
var randomStrategy = false;
var height = 90;
var buttons = ['HButton', 'CButton', 'OButton', 'QButton', 'FButton', 'IButton'];
var positionY = [100, 150, 200, 250, 300, 350];
var buttonsList = [];
var floor;
var group;
var doneButton;
var deleteButton

function preload() {
		game.load.image('CButton', 'images/CAtoomButtonBrown.png');
		game.load.image('OButton', 'images/OAtomButtonBrown.png');
		game.load.image('HButton', 'images/HAtoomButtonBrown.png');
		game.load.image("FButton", 'images/FAtomButton.png')
		game.load.image("QButton", 'images/BrAtomButton.png')
		game.load.image("IButton", 'images/IAtomButton.png')
		game.load.image('delete', 'images/garbage.png');
		game.load.image('C', 'images/CAtom1.png');
		game.load.image('H', 'images/HAtom.png');
		game.load.image('O', 'images/OAtom.png');
		game.load.image('I', 'images/IAtom.png');
		game.load.image('Q', 'images/BrAtom.png');
		game.load.image('F', 'images/FAtom.png');
		game.load.image('done', 'images/doneButton.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion');
		game.load.image('start', 'images/start.png');
		game.load.text('questions', 'questions.txt');
}

function create() {
	var graphics1 = game.add.graphics(0, 0);
	var graphics2 = game.add.graphics(0, 0);
	var whiterect = game.add.graphics(0, 0);

	graphics1.beginFill(0xffdd99);
	graphics2.beginFill(0xAAAAAA);
	whiterect.beginFill(0xe6f2ff);

	graphics1.drawRect(10, 10, 80, 480); //3

	graphics1.drawRect(10, 500, 80, 90); //4

	graphics1.drawRect(100, 500, 575, 90); //5

	graphics1.drawRect(685, 500, 105, 90); //6

	graphics1.drawRect(685, 10, 105, 480); //7

	whiterect.drawRect(100,10, 575, 480); //2

	makeStartPopup();
	readQuestion();
	makePriorityQue();
	currentQuestion = decideQuestion();

	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		console.log("Klaar");
	}
	var atomValues = ['H', 'C', 'O', 'Q', 'F', 'I'];
	game.stage.backgroundColor = "#DBB782";
	// Make buttons
	console.log(currentQuestion.group);
	currentQuestion.makeButtons();
	doneButton = game.add.button(700, 520, 'done', evaluateAnswer, this);

	deleteButton = game.add.image(12, 500, 'delete');

	deleteButton.scale.setTo(0.4, 0.4);
	doneButton.scale.setTo(0.50, 0.50);
	doneButton.visible = false;
	deleteButton.visible = false;

	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = false;
	}
}

function render () {
    game.debug.geom(floor,'#ffffff');
}

function makeStartPopup(){
	var startTextofGame = document.getElementById('startTextofGame');
	startTextofGame.innerText =
		"You are working in a laboratory. " +
		"When you click on Start you are asked to complete some important missions! " +
		"Try to complete as many mission as you can and become rich! The bar on the right gives you an indication of how much money you are earning. " +
		"We need you, do not disappoint us."
}

function startG(){
	firstpopup.style.display = 'none';
	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = true;
	}
	deleteButton.visible = true;
	doneButton.visible = true;
	console.log('start');
}

function determineOveralDifficulty(){
	var sum = 0;
	for(var i=0; i < listOfQuestions.length; i++){
		sum = sum + listOfQuestions[i].difficulty
		console.log(listOfQuestions[i].currentQuestionText +  ", " + listOfQuestions[i].difficulty);
	}
	return sum;
}

function move(amount) {
		this.amount = amount;
    var elem = document.getElementById("myBar");
		var currentHeigth = this.height;
    var id = setInterval(frame, 20);

    function frame() {
			this.amount = Math.floor(this.amount);
			if(this.amount < 0){
				if (this.height >= (currentHeigth + this.amount)) {
					if((currentHeigth + this.amount) >= 1){
						this.height--;
						elem.style.height = this.height + '%';
      		}
					else{
						while(this.height >= 1){
							this.height--;
							elem.style.height = this.height + '%';
						}
						setSalary(0);
						return this.height;
					}
				}
			}
			else{
				if (this.height <= (currentHeigth + this.amount)){
					if(currentHeigth + this.amount <= 100){
	        	this.height++;
						elem.style.height = this.height + '%';
					}
					else{
					 	while(this.height <= 100){
					 		this.height++;
					 		elem.style.height = this.height + '%';
					 	}
					 	setSalary(100);
					 	return this.height;
					}
				}
    	}
		}

		setSalary(this.height);
		console.log(this.height);
		return this.height;
}



function setSalary(height){
	var salarytext = document.getElementById('salarytext');
	if(height == 100){
		salarytext.innerText = "Your salary is " + 0 + " euro.";
		var color = changeColorOfProgressBar(0);
		//salarytext.style.color = color;
	}
	else if(height == 0){
		salarytext.innerText = "Your salary is " + 100 + " euros.";
		var color = changeColorOfProgressBar(100);
		//salarytext.style.color = color;
	}
	else{
		var score = Math.floor(100 - (+height + +this.amount));
		salarytext.innerText = "Your salary is " + score + " euros.";
		console.log(+height + +this.amount);
		var color = changeColorOfProgressBar(score);
		//salarytext.style.color = color;
	}
}

function changeColorOfProgressBar(score){
	var elem = document.getElementById("myProgress");
	//var score = 100 - this.height;
	console.log("Score is nu " + score);
	if(score <= 10){
		elem.style.backgroundColor = "red";
		return "red";
	}
	else if(score <= 30 && score > 10){
		elem.style.backgroundColor = "orange";
		return "orange";
	}
	else if(score <= 50 && score > 30){
		elem.style.backgroundColor = "yellow";
		return "yellow";
	}
	else if(score <= 65 && score > 50){
		elem.style.backgroundColor = "#ccff66";
		return "#ccff66";
	}
	else{
		elem.style.backgroundColor = "#669900";
		return "#669900";
	}
}

function moveTo(amount){
	var elem = document.getElementById("myBar");
	console.log(amount);
	this.amount = amount;
	elem.style.height = amount + '%';
	this.height = amount;
	return this.height;
}

function deleteAtom(){
	console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 35 && this.sprite.x > 5 && this.sprite.y > 440 && this.sprite.y < 530){
		console.log(this.sprite.x + " " + this.sprite.y);
		// je moet ook het atom verwijderen uit currentMolecule
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0){
			priorityQueueQuestions[0].isAsked = true;
			return priorityQueueQuestions[0];
		}
		console.log("hhallooo");
		return decideAdaptively();
	}
}

function makePriorityQue(){
	var priority = [];
	for(var i=0; i<listOfQuestions.length; i++){
		priority.push(listOfQuestions[i].difficulty);
	}
	priority = priority.sort(function(a,b){
		return (+a) - (+b);
	});
	for(var i=0; i<priority.length; i++){
		for(var j=0; j<listOfQuestions.length; j++){
			if(priority[i] == listOfQuestions[j].difficulty && !priorityQueueQuestions.includes(listOfQuestions[j])){
				this.priorityQueueQuestions.push(listOfQuestions[j]);
				console.log(listOfQuestions[j].currentQuestionText + " ");
			}
		}
	}
}

function pickRandomQuestion(){
	var x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	while(priorityQueueQuestions[x].isAsked == true){
		x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	}
	priorityQueueQuestions[x].isAsked = true;
	return priorityQueueQuestions[x];
}

function pickAdaptively(){
	console.log(currentQuestion.score);
	if(currentQuestion.score == 1){
		for(var i=0; i<priorityQueueQuestions.length; i++){
			if(priorityQueueQuestions[i].difficulty - currentQuestion.difficulty>= 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
	else if(currentQuestion.score == 0.75){
		for(var i=0; i < priorityQueueQuestions.length; i++){
			if(currentQuestion.difficulty - priorityQueueQuestions[i].difficulty <= 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
	else{
		for(var i=0; i < priorityQueueQuestions.length; i++){
			if(currentQuestion.difficulty - priorityQueueQuestions[i].difficulty == 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
}

function decideAdaptively(){
	console.log("hallooooo?");
	for(var i=0; i< priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].repeat || !priorityQueueQuestions[i].isAsked){
			console.log(priorityQueueQuestions.repeat +  ", deze ga ik doen: " + priorityQueueQuestions[i].molecule);
			priorityQueueQuestions[i].isAsked = true;
			priorityQueueQuestions[i].repeat = false;

			return priorityQueueQuestions[i];
		}
	}

}

function restartGame(){
	for(var i=0; i < priorityQueueQuestions.length; i++){
		priorityQueueQuestions[i].isAsked = false;
		priorityQueueQuestions[i].score = 0;
	}
	if(!randomStrategy){
		currentQuestion.finishGame();
	}
	console.log("Zo hoog is hij nu " + this.height);

	//this.height = moveTo(90);
	this.height = move(this.height);
	finish.style.display = 'none';
	var salarytext = document.getElementById('salarytext');
	salarytext.innerText = "Your salary is " + (this.height) + " euros.";
	showNextQuestion();
}

function finishGame(){
	finish.style.display = 'none';
	// Verwijder de vraag onderaan.
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
	console.log("klaar!");
}

function getScore(){
	var sum = 0;
	for(var i=0; i < priorityQueueQuestions.length; i++){
			sum += priorityQueueQuestions[i].score;
	}
	return sum/priorityQueueQuestions.length * 10;
}

function allQuestionsAreAsked(){
	for(var i=0; i<priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				trial.molecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
				trial.copyMolecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
			}
		}
		else if(textsQuestion[i].indexOf('Familiarity') > -1){
			var familiarity = textsQuestion[i].split(/~/);
			trial.familiarity = familiarity[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
						trial.copyMolecule[k].addConnection(trial.copyMolecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			trial.determineDifficulty();
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			console.log("You are going to make a new question now!");
			makeTrial(new Trial(game, group), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	var textAnswer = document.getElementById('textAnswer');
	textAnswer.style.color = "black";
	popup.style.display = 'none';
	currentQuestion = decideQuestion(priorityQueueQuestions);
	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	var score = document.getElementById('score');
	gameDone.innerText = text;
	score.innerText = "Your score is " + getScore().toFixed(2);
	finish.style.display = 'block';
}

// This function should call the next question. It is now callin the checkTheAnswer function which checks if the molecule built is the correct molecule.
// After that it destroys the sprites and empties the currentMolecule list. This function needs to be split up.
function evaluateAnswer(){
	printMolecule();

	feedbackText = [];
	if(!gameIsFinished){

		if(checkTheAnswer()){
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				currentQuestion.score = 1;
				textAnswer.innerText = 'Great job!';
				popup.style.display = 'block';
				console.log(determineShiftInBar(-1));
				this.height = move(determineShiftInBar(-1));
			}
			else{
				currentQuestion.score = 1;
				showLastPopup('Great Job!');
				console.log(determineShiftInBar(-1));
				var score = determineShiftInBar(-1);
				console.log("score is " + score);
				this.height =  move(score);
			}
		}
		else{
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				textAnswer.style.color = "red";
				textAnswer.innerText = 'Your answer is incorrect. ' + feedbackText;
				popup.style.display = 'block';
			}
			else{
				showLastPopup('Your answer is incorrect.');
			}
		}
		for(var i=0; i<currentQuestion.currentMolecule.length; i++){
			currentQuestion.currentMolecule[i].sprite.destroy();
		}
		currentQuestion.currentMolecule = [];
	}
}

function printMolecule(){
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		console.log("Dit is Atom nummer " +  i + ", " + currentQuestion.currentMolecule[i].value + ", " + currentQuestion.currentMolecule[i].id);
		console.log(currentQuestion.currentMolecule[i]);
	}

}

// this function checks whether the currentMolecule has the right amount of atoms and the correct neighbours for each atom.
function checkTheAnswer(){
	if(currentQuestion.currentMolecule.length != currentQuestion.molecule.length){
		console.log('You do not have the right amount of atoms!');
		feedbackText = 'You do not have the right amount of atoms!';
		this.height = move(determineShiftInBar(1.0));
		console.log(this.height);
		currentQuestion.repeat = true;
		return false;
	}
	else{
		for(var j=0; j< currentQuestion.molecule.length; j++){
			if(countNumberOfAtoms(currentQuestion.molecule, currentQuestion.molecule[j].value) != countNumberOfAtoms(currentQuestion.currentMolecule, currentQuestion.molecule[j].value)){
					currentQuestion.score = 0.50;
					this.height = move(determineShiftInBar(-0.5));
					console.log(determineShiftInBar(-0.5));
					feedbackText = 'You do not have the right types of atoms';
					currentQuestion.repeat = true;
					return false;
			}
		}
		currentQuestion.score = 0.75;
		this.height = move(determineShiftInBar(-0.75));
		console.log(determineShiftInBar(-0.75));
		return checkNeighbours();
	}
}

function determineShiftInBar(answerScore){
	var score = 85 - determineOveralDifficulty();
	if(answerScore > 0){
		console.log("Dit ga ik nu verplaatsen +" + (((answerScore*score)/priorityQueueQuestions.length) + currentQuestion.difficulty));
		return ((answerScore*score)/priorityQueueQuestions.length) + currentQuestion.difficulty;
	}
	else{
		console.log("Dit ga ik nu verplaatsen -" + (((answerScore*score)/priorityQueueQuestions.length) - currentQuestion.difficulty));
		return ((answerScore*score)/priorityQueueQuestions.length) - currentQuestion.difficulty;
	}
}

// maak kopie van correct antwoord zodat je als je het antwoord fout hebt, nog verder kan gaan om het te verbeteren.
// check eerst of values of atomen gelijk zijn en kijk daarna naar de verbindingen ervan. Sorteer neighbours op alfabetische volgorde en check of de lijstjes
// gelijk zijn, als dat zo is, verwijder het atoom uit het correcte antwoord, zo niet dan return false

// you need to delete the neighbour if it is right otherwise you could find it again while it is checked already
// This function checks whether each atom of currentMolecule has the correct neighbours. (It is still not working.)
function checkNeighbours(){
	for(var k=0; k< currentQuestion.molecule.length; k++){
		for(var f=0; f< currentQuestion.currentMolecule.length; f++){
			if(currentQuestion.molecule[k].value == currentQuestion.currentMolecule[f].value){
				currentQuestion.molecule[k].neighbour.sort(function(a, b){
						return a.value < b.value;
				});
				for(var v=0; v<currentQuestion.molecule[k].neighbour.length; v++){
					console.log("neighbour: " + currentQuestion.molecule[k].neighbour[v].value);
				}
				currentQuestion.currentMolecule[f].neighbour.sort(function(a, b){
					return a.value < b.value;
				});
				if(!equalLists(currentQuestion.molecule[k].neighbour, currentQuestion.currentMolecule[f].neighbour)){
					feedbackText = 'You do not have the right connections between the atoms.';
					return false;
				}
				console.log(k);
				// moet deze splice nou wel of niet? Want zonder deze gaat het wel goed, nog over nadenken!!
				currentQuestion.molecule.splice(k, 1);
			}
		}
	}
	currentQuestion.molecule = currentQuestion.copyMolecule;
	return true;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function checks whether a specific atom has the right neighbours.
function checkNeighboursOfAtom(a, b){
	var boolean = false;
		for(var i=0; i < a.neighbour.length; i++){
				for(var j=0; j< b.neighbour.length; j++){
					if(countNumberOfAtoms(a.neighbour, a.neighbour[i].value) == countNumberOfAtoms(b.neighbour, a.neighbour[i].value)){
						boolean = true;
					}
					else{
						console.log("het ging hier fout" + countNumberOfAtoms(a.neighbour, a.neighbour[i].value) + ' ' + countNumberOfAtoms(b.neighbour, a.neighbour[i].value));
						return boolean = false;
					}
				}
		}
		return boolean;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
  //  if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element)){
		if(!gameIsFinished){
  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
  		var atomNew = new Atom(element, true, id, game);
  		currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
  	//}
		}
  }
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
	game.world.bringToTop(button);
	buttonsList.push(button);
  button.scale.setTo(0.3, 0.3);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			//console.log(atomB.id);
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
