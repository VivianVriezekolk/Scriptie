
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src="atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
		<div id="startG" class= "firstpopup">
			<p id = "startTextofGame"></p>
			<input type= "image" src = "images/start.png" id= "startButton" onclick ="startG()">
		</div>
		<div id="wrongAnswer" class = "popup" >
			<div class = "popup-content">
				<p id = "textAnswer"></p>
				<!--'<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">-->
			</div	>
		</div>

		<div id= "gamedone" class = "popup">
			<div class = "popup-content">
				<p id = "finishText"></p>
			</div>
		</div>

		<div id= "totalScore" class= "lastpopup">
			<div class = "popup-content">
				<p id = "score"><b> </b></p>
			</div>
		</div>

		<div class = "progressText">
			<div class = "textProgresscontent">
				<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Current Salary</p>
			</div>
		</div>

		<div class = "atomButtons">
			<div class = "textProgresscontent">
				<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Atom creators</p>
			</div>
		</div>

		<div class = "progress">
			<div id="myProgress">
		  	<div id="myBar"></div>
			</div>
		</div>

		<div class = "amountSalary">
			<div class = "SalaryContent">
				<p id="salarytext" style="font: 15px times new roman; color: green;"></p>
			</div>
		</div>

	<div id= "missionTextPopup" class = "missionPopup">
		<div class = "mission-content">
			<p id = "missionText"></p>
		</div>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render});

var popup = document.getElementById('wrongAnswer');
var finish = document.getElementById('gamedone');
var last = document.getElementById('totalScore');
var firstpopup = document.getElementById('startG');
var missionpopup = document.getElementById('missionTextPopup');
var bar = document.getElementById("myBar");

bar.style.height = "90%";

var currentQuestion = new Trial(game);
var id = 0;
var height = 90;

var listOfQuestions = [];
var priorityQueueQuestions = [];
var text = [];
var feedbackText = [];
var buttonsList = [];

var buttons = ['HButton', 'CButton', 'OButton', 'QButton', 'FButton', 'IButton', 'ZButton'];
var positionY = [75, 125, 175, 225, 275, 325, 375];
var atomValues = ['H', 'C', 'O', 'Q', 'F', 'I', 'Z'];
var covalences = [1,4,2,1,1,1,1,1];
var gameIsFinished = false;
var randomStrategy = false;
//var uniqueButtons = false;
//var hintConnections = false;
var giveHints = false;
var evaluateAnswer = false;

var floor;
var doneButton;
var deleteButton;
var nextQuestion;
var next;
var restart;

var totalScore = 10; // van 0 tot 100. 0 is niks 100 is alles.

function preload() {
		game.load.image('CButton', 'images/CAtoomButtonGreen.png');
		game.load.image('OButton', 'images/OAtoomButtonGreen.png');
		game.load.image('HButton', 'images/HAtoomButtonGreen.png');
		game.load.image("FButton", 'images/FAtoomButtonGreen.png');
		game.load.image("QButton", 'images/BrAtoomButtonGreen.png');
		game.load.image("IButton", 'images/IAtoomButtonGreen.png');
		game.load.image("ZButton", "images/ClAtoomButtonGreen.png");
		game.load.image("Z", "images/ClAtomCircle.png");
		game.load.image('delete', 'images/garbage.png');
		game.load.image('C', 'images/CAtomCircle.png');
		game.load.image('H', 'images/HAtomCircle.png');
		game.load.image('O', 'images/OAtomCircle.png');
		game.load.image('I', 'images/IAtomCircle.png');
		game.load.image('Q', 'images/BrAtomCircle.png');
		game.load.image('F', 'images/FAtomCircle.png');
		game.load.image('done', 'images/doneButton2.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion.png');
		game.load.image('next', 'images/next.png');
		game.load.image('start', 'images/start.png');
		game.load.image('finish', 'images/finish.png');
		game.load.text('questions', 'questions.txt');
}

function create(){
	var graphics1 = game.add.graphics(0, 0);
	var graphics2 = game.add.graphics(0, 0);
	var whiterect = game.add.graphics(0, 0);

	graphics1.beginFill(0xffdd99);
	graphics2.beginFill(0xAAAAAA);
	whiterect.beginFill(0xe6f2ff);

	graphics1.drawRect(10, 10, 80, 480); //3

	graphics1.drawRect(10, 500, 80, 90); //4

	graphics1.drawRect(100, 500, 575, 90); //5

	graphics1.drawRect(685, 500, 105, 90); //6

	graphics1.drawRect(685, 10, 105, 480); //7

	whiterect.drawRect(100,10, 575, 480); //2

	makeStartPopup();
	readQuestion();
	makePriorityQueue();
	currentQuestion = decideQuestion();

	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		console.log("Klaar");
	}
	game.stage.backgroundColor = "#DBB782";
	// Make buttons
	doneButton = game.add.button(675, 505, 'done', evaluateAnswer3, this);
	nextQuestion = game.add.button(680, 500, 'nextQuestion', showNextQuestion, this);
	deleteButton = game.add.image(12, 500, 'delete');
	next = game.add.button(675, 500, 'next', showTotalScore, this);

	deleteButton.scale.setTo(0.4, 0.4);
	doneButton.visible = false;
	deleteButton.visible = false;
	nextQuestion.visible = false;
	next.visible = false;

	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = false;
	}
}

function makeButtons(){
	for(var i=0; i< buttons.length; i++){
		var buttonTest = new button(buttons[i], atomValues[i], 30, positionY[i]);
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0 && !currentQuestion.alreadyAdded){
			priorityQueueQuestions[0].isAsked = true;
			changeCovalence(priorityQueueQuestions[0]);
			priorityQueueQuestions[0].determineCovalence();
			return priorityQueueQuestions[0];
		}
		return decideAdaptively();
	}
}

function render () {
    game.debug.geom(floor,'#ffffff');
}

function makeStartPopup(){
	var startTextofGame = document.getElementById('startTextofGame');
	startTextofGame.innerText =
		"You are working in a laboratory. " +
		"When you click on Start you are asked to complete some important missions! " +
		"Try to complete as many mission as you can and become rich! The bar on the right gives you an indication of how much money you are earning. " +
		"We need you, do not disappoint us."
}

function startG(){
	firstpopup.style.display = 'none';
	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = true;
	}
	deleteButton.visible = true;
	doneButton.visible = true;
	console.log('start');
}

function determineOveralDifficulty(){
	var sum = 0;
	for(var i=0; i < listOfQuestions.length; i++){
		sum = sum + listOfQuestions[i].difficulty;
	}
	return sum;
}

function updateBar() {
	var SPEED = 1;
	var MINIMUM_EPSILON = 1;

	var elem = document.getElementById("myBar");
	var goalHeight = 100 - this.totalScore;
	var id = setInterval(frame, 20);

	function frame() {
		var currentHeight = parseInt(elem.style.height);
		var epsilon = goalHeight - currentHeight;
		if (Math.abs(epsilon) < MINIMUM_EPSILON)
			clearInterval(id);
		var newHeight = currentHeight + SPEED * Math.sign(epsilon)
		elem.style.height = newHeight + '%';
	}
}

function updateBarColor(){
	var elem = document.getElementById("myProgress");
	if(totalScore <= 10){
		elem.style.backgroundColor = "red";
	}
	else if(totalScore <= 30 && totalScore > 10){
		elem.style.backgroundColor = "orange";
	}
	else if(totalScore <= 50 && totalScore > 30){
		elem.style.backgroundColor = "yellow";
	}
	else if(totalScore <= 65 && totalScore > 50){
		elem.style.backgroundColor = "#ccff66";
	}
	else{
		elem.style.backgroundColor = "#669900";
	}
}

function updateSalary(){
	var salarytext = document.getElementById('salarytext');
	var roundScore = 60 * Math.round(totalScore);
	if(roundScore == 1){
		salarytext.innerText = "Your salary is " + 1 + " euro.";
	}
	else{
		salarytext.innerText = "Your salary is " + roundScore + " euros.";
	}
}

function deleteAtom(){
	console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 35 && this.sprite.x > 5 && this.sprite.y > 440 && this.sprite.y < 530){
		console.log(this.sprite.x + " " + this.sprite.y);
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function makePriorityQueue(){
	var priority = [];
	for(var i=0; i<listOfQuestions.length; i++){
		priority.push(listOfQuestions[i].difficulty);
	}
	priority = priority.sort(function(a,b){
		return (+a) - (+b);
	});
	for(var i=0; i<priority.length; i++){
		for(var j=0; j<listOfQuestions.length; j++){
			if(priority[i] == listOfQuestions[j].difficulty && !priorityQueueQuestions.includes(listOfQuestions[j])){
				this.priorityQueueQuestions.push(listOfQuestions[j]);
				console.log(listOfQuestions[j].currentQuestionText + " ");
			}
		}
	}
}

function pickRandomQuestion(){
	var x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	while(priorityQueueQuestions[x].isAsked == true){
		x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	}
	priorityQueueQuestions[x].isAsked = true;
	return priorityQueueQuestions[x];
}

function decideAdaptively(){
	decideOrderQuestions();
	for(var i=0; i< priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false || priorityQueueQuestions[i].repeat >= 1){
			priorityQueueQuestions[i].isAsked = true;
			if(priorityQueueQuestions[i].repeat > 0){
				priorityQueueQuestions[i].repeat -= 1;
			}
			return priorityQueueQuestions[i];
		}
	}
}

function decideOrderQuestions(){
// de waardes moeten nog aangepast worden, het moet ook zo zijn dat ze worden herhaald als de vragen weer wat moeilijker worden, nog even naar kijken.

	for(var i=0; i < priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == -1){
			var position = Math.min(priorityQueueQuestions.length, i+3);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			console.log(priorityQueueQuestions[position]);
			return;
		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == 0.75){
			var position = Math.min(priorityQueueQuestions.length, i+4);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			console.log(priorityQueueQuestions[position]);
			return;

		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == 0.5){
			var position = Math.min(priorityQueueQuestions.length, i+5);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			console.log(priorityQueueQuestions[position]);
			return;

		}
		else if(priorityQueueQuestions[i] == currentQuestion && currentQuestion.score == 0.25){
			var position = Math.min(priorityQueueQuestions.length, i+6);
			priorityQueueQuestions.splice(position, 0, priorityQueueQuestions[i]);
			priorityQueueQuestions.splice(i, 1);
			console.log(priorityQueueQuestions[position]);
			return;
		}
	 }
}

function determineText(){
	if(totalScore < 55){
		return 'Your salary is not that high, perhaps you should take a second job.';
	}
	else if(totalScore < 70 && totalScore > 55){
		return 'Great job!';
	}
	else{
		return 'Excellent. You\'ve become rich!';
	}
}

// hier nog even naar kijken!
function showTotalScore(){
	deleteSprites();
	next.visible = false;
	last.style.display = 'block';
	var lastPop = document.getElementById('score');
	finish.style.display = 'none';
	var endText = determineText();
	lastPop.innerText = "Your final salary is " + 60* Math.floor(totalScore) + " euros. " + endText;
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	if(text.indexOf('incorrect') > -1){
		gameDone.style.color = 'red';
	}
	gameDone.innerText = text;
	finish.style.display = 'block';
	next.visible = true;
}

function restartGame(){
	for(var i=0; i < priorityQueueQuestions.length; i++){
		priorityQueueQuestions[i].isAsked = false;
		priorityQueueQuestions[i].repeat = -1;
		priorityQueueQuestions[i].score = 0;
	}
	if(!randomStrategy){
		currentQuestion.finishGame();
	}
	totalScore = 10;
	updateBar();
	updateSalary();
	showNextQuestion();
}

function finishGame(){
	deleteSprites();
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
}

function getScore(){
	var sum = 0;
	for(var i=0; i < priorityQueueQuestions.length; i++){
			sum += priorityQueueQuestions[i].score;
	}
	return sum/priorityQueueQuestions.length * 10;
}

function allQuestionsAreAsked(){
	console.log(priorityQueueQuestions.length);
	for(var i=0; i<priorityQueueQuestions.length; i++){
		console.log(priorityQueueQuestions[i].moleculeName, priorityQueueQuestions[i].repeat);
		if(priorityQueueQuestions[i].isAsked == false || priorityQueueQuestions[i].repeat > 0){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Name') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.moleculeName = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				var atom = new Atom(atomsOfMolecule[j], false, id+j, game);
				trial.molecule.push(atom);
				trial.copyMolecule.push(atom);
			}
		}
		else if(textsQuestion[i].indexOf('Familiarity') > -1){
			var familiarity = textsQuestion[i].split(/~/);
			trial.familiarity = familiarity[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
						trial.copyMolecule[k].addConnection(trial.copyMolecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			trial.determineDifficulty();
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			console.log("You are going to make a new question now!");
			makeTrial(new Trial(game), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	evaluateAnswer = false;
	deleteSprites();
	nextQuestion.visible = false;
	doneButton.visible = true;
	var textAnswer = document.getElementById('textAnswer');
	textAnswer.style.color = "black";
	popup.style.display = 'none';
	missionpopup.style.display = 'block';
	currentQuestion = decideQuestion(priorityQueueQuestions);
	if(currentQuestion != null){
		changeCovalence(currentQuestion);
		currentQuestion.determineCovalence();
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function changeCovalence(question){
	console.log(question.moleculeName);
	if(question.moleculeName == 'Carbondioxide'){
		covalences = [1,2,1,1,1,1,1,1];;
	}
	else if(question.moleculeName == "Oxygen"){
		covalences = [1,4,1,1,1,1,1,1];;
	}
	else{
		covalences = [1,4,2,1,1,1,1,1];
	}
}

function evaluateAnswer3(){
	evaluateAnswer = true;
	var tooMany = false;
	var rightAmount = currentQuestion.checkAmountOfAtoms();
	var rightUnique = currentQuestion.checkUniqueAtoms();
	var rightType = currentQuestion.checkAmountOfTypeOfAtoms();
	// rightconnections doet het nog niet helemaal goed lijkt het.
	var rightConnections = currentQuestion.checkConnections2();

	if(!rightAmount){
		var amountMolecule = currentQuestion.molecule.length;
		var amountCurrent = currentQuestion.currentMolecule.length;
		if(amountMolecule - amountCurrent > 0){
			tooMany = true;
		}
		else{
			tooMany = false;
		}
	}
	console.log(rightAmount, rightType, rightUnique, rightConnections);
	determineScore(rightType, rightConnections, rightAmount, rightUnique, tooMany);
}

function determineScore(rightType, rightConnections, rightAmount, rightUnique, tooMany){
	if(!gameIsFinished){
		if(rightType && rightConnections && rightAmount && rightUnique){
			// als je het goed hebt wordt de vraag niet nog een keer gesteld, anders wel.
			currentQuestion.repeat = 0;
			setProgress('Great Job!', 1, 'black');
		}
		else if(rightType && !rightConnections && rightAmount && rightUnique){
			setProgress('Your answer is incorrect. You do not have the right connections between atoms.', 0.5, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.4;
				currentQuestion.repeat = 1;
			}
			currentQuestion.hintConnections = true;
		}
		else if(!rightAmount && rightConnections){
			setProgress('Your answer is incorrect. You have too many atoms, but you are almost there!', 0.25, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.20;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
		}
		else if(!rightType && rightConnections && rightUnique){
			setProgress('Your answer is incorrect. You have the right connections but you are still missing some atoms.', 0.25, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore == 0.20;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
		}
		else if(!rightAmount && !rightUnique){
			// het kan zijn dat er wel 1 atoom bij zat die er in moet zitten, dus de tekst klopt hier niet helemaal.
			setProgress('Your answer is incorrect. You do not have the right amount of atoms. You also need to use other atoms.', -1, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.1;
				currentQuestion.repeat = 3;
				console.log(currentQuestion.maxScore);
			}
			currentQuestion.uniqueButtons = true;
		}
		else if(rightUnique){
			// kan ook zijn dat je er te veel hebt.
			setProgress('Your answer is incorrect. You do use the right atoms, but you are still missing atoms.', 0.25, 'red');
			if(currentQuestion.repeat == -1){
				currentQuestion.maxScore = 0.25;
				currentQuestion.repeat = 2;
				console.log(currentQuestion.maxScore);
			}
		}
	}
}

function setProgress(feedback, score, colour){
	console.log(currentQuestion.maxScore);
	console.log(totalScore);
	totalScore += convertScoreChange(score*currentQuestion.maxScore);
	console.log(totalScore);
	totalScore = Math.max(0,totalScore);
	updateBar();
	updateBarColor();
	updateSalary();
	currentQuestion.score = score;

	if(allQuestionsAreAsked()){
		doneButton.visible = false;
		nextQuestion.visible = false;
		popup.style.display = 'none';
		missionpopup.style.display = 'none';
		showLastPopup(feedback);
	}
	else{
		var textAnswer = document.getElementById('textAnswer');
		textAnswer.style.color = colour;
		textAnswer.innerText =  feedback;
		doneButton.visible = false;
		nextQuestion.visible = true;
		popup.style.display = 'block';
		missionpopup.style.display = 'none';
	}
}

function deleteSprites(){
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		currentQuestion.currentMolecule[i].sprite.destroy();
	}
	currentQuestion.currentMolecule = [];
}

function addWrongQuestion(){
	var currentLength = priorityQueueQuestions.length;
	for(var i=0; i < currentQuestion.repeat; i++){
		if(!currentQuestion.alreadyAdded){
			priorityQueueQuestions.push(currentQuestion);
			console.log(currentQuestion);
		}
	}
	if(currentLength != priorityQueueQuestions.length){
		currentQuestion.alreadyAdded = true;
		console.log("deze ga ik niet adden");
	}
	console.log(priorityQueueQuestions.length);
}

function printMolecule(){
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		console.log("Dit is Atom nummer " +  i + ", " + currentQuestion.currentMolecule[i].value + ", " + currentQuestion.currentMolecule[i].id);
		console.log(currentQuestion.currentMolecule[i]);
	}
}

function convertScoreChange(answerScore) {
	var totalDifficulty = determineOveralDifficulty();
	return answerScore * 90 * currentQuestion.difficulty / totalDifficulty;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
  //  if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element)){
		if(!gameIsFinished){
  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
  		var atomNew = new Atom(element, true, id, game);
			atomNew.covalence = atomNew.determineCovalence();
  		currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
  	//}
		}
  }
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
	game.world.bringToTop(button);
	buttonsList.push(button);
  button.scale.setTo(0.3, 0.3);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
					currentMolecule[i].determineTint();
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
		currentMolecule[i].determineTint();
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
