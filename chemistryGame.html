
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src="atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
	<div id="startG" class= "firstpopup">
		<p id = "startTextofGame"></p>
		<input type= "image" src = "images/start.png" id= "startButton" onclick ="startG()">
	</div>
	<div id="wrongAnswer" class = "popup" >
		<div class = "popup-content">
			<p id = "textAnswer"></p>
			<!--<input type= "image" src = "images/tryAgain.png" id= "Okbutton" onclick ="showNextQuestion()">-->
			<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">
		</div	>
	</div>
	<div id= "gamedone" class = "popup">
		<div class = "popup-content">
			<p id = "finishText"></p>
			<p id = "score"></p>
			<input type= "image" src = "images/finish.png" id= "Okbutton" onclick ="finishGame()">
			<input type= "image" src = "images/restart.png" id= "Okbutton" onclick ="restartGame()">
		</div>
	</div>
	<div id="myProgress" class = "progress">
  	<div id="myBar"></div>
	</div>
<div id= "missionTextPopup" class = "missionPopup">
	<div class = "mission-content">
		<p id = "missionText"></p>
	</div>
</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update});
var copyMolecule = [];
var group;
var currentQuestion = new Trial(game, group);
var id = 0;
var listOfQuestions = [];
var priorityQueueQuestions = [];
var text = [];
var feedbackText = [];
var popup = document.getElementById('wrongAnswer');
var finish = document.getElementById('gamedone');
var firstpopup = document.getElementById('startG');
var missionpopup = document.getElementById('missionTextPopup');
var gameIsFinished = false;
var randomStrategy = true;
var height = 50;
var buttons = ['HButton', 'CButton', 'OButton'];
var positionY = [150, 200, 250];
var buttonsList = [];

function preload() {
		game.load.image('CButton', 'images/CAtoomButton.png');
		game.load.image('OButton', 'images/OAtoomButton.png');
		game.load.image('HButton', 'images/HAtoomButton.png');
		game.load.image('delete', 'images/deleteP.png');
		game.load.image('C', 'images/CAtom.png');
		game.load.image('H', 'images/HAtom.png');
		game.load.image('O', 'images/OAtoom.png');
		game.load.image('done', 'images/doneButton.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion');
		game.load.image('start', 'images/start.png');
		game.load.text('questions', 'questions.txt');
}

function create() {
		group = game.add.group();
		makeStartPopup();
		readQuestion();
		makePriorityQue();
		currentQuestion = decideQuestion();

		if(currentQuestion != null){
			currentQuestion.showQuestion();
		}
		else{
			console.log("Klaar");
		}
		var atomValues = ['H', 'C', 'O'];
		game.stage.backgroundColor = "#ADD8E6";

		// Make buttons
		console.log(currentQuestion.group);
		currentQuestion.makeButtons();
		// for(var i=0; i< atomValues.length; i++){
		// 	console.log(buttons[i]);
		// 	var buttonTest = new button(buttons[i],atomValues[i], 30, positionY[i]);
		// }

		var doneButton = game.add.button(600, 515, 'done', evaluateAnswer, this);
		var deleteButton = game.add.image(10, 500, 'delete');

		deleteButton.scale.setTo(0.2, 0.2);
		doneButton.scale.setTo(0.7, 0.7);
}

function makeStartPopup(){
	var startTextofGame = document.getElementById('startTextofGame');
	startTextofGame.innerText = "You are working in a laboratory. When you click on Start Game you are asked to complete some missions! We need you, do not disappoint us."
}

function startG(){
	firstpopup.style.display = 'none';
	console.log('start');
}

function move(amount) {
		this.amount = amount;
    var elem = document.getElementById("myBar");
		this.currentHeigth = this.height;
    var id = setInterval(frame, 20);

    function frame() {
			this.amount = Math.floor(this.amount);
			console.log(this.currentHeigth + this.amount);
			if(this.amount < 0){
				if (this.height >= this.currentHeigth + this.amount) {
					if(this.height >= 1){
						this.height--;
						console.log(this.height + '%');
						elem.style.height = this.height + '%';
      		}
				}
			}
			else{
				if (this.height <= this.currentHeigth + this.amount && this.height <= 100){
        	this.height++;
					console.log(this.height + '%');
					elem.style.height = this.height + '%';
      	}
    	}
		}
		console.log(this.height);
		return this.height;
}

function moveTo(amount){
	var elem = document.getElementById("myBar");
	console.log(amount);
	this.amount = amount;
	elem.style.height = amount + '%';
	this.height = amount;
	return this.height;
}

function deleteAtom(){
	console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 35 && this.sprite.x > 10 && this.sprite.y > 450 && this.sprite.y < 530){
		console.log(this.sprite.x + " " + this.sprite.y);
		// je moet ook het atom verwijderen uit currentMolecule
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0){
			priorityQueueQuestions[0].isAsked = true;
			return priorityQueueQuestions[0];
		}
		return pickAdaptively();
	}
}

function makePriorityQue(){
	var priority = [];
	for(var i=0; i<listOfQuestions.length; i++){
		priority.push(listOfQuestions[i].difficulty);
	}
	priority.sort();

	for(var i=0; i<priority.length; i++){
		for(var j=0; j<listOfQuestions.length; j++){
			if(priority[i] == listOfQuestions[j].difficulty && !priorityQueueQuestions.includes(listOfQuestions[j])){
				this.priorityQueueQuestions.push(listOfQuestions[j]);
				console.log(listOfQuestions[j].currentQuestionText + " ");
			}
		}
	}
}

function pickRandomQuestion(){
	var x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	while(priorityQueueQuestions[x].isAsked == true){
		x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	}
	priorityQueueQuestions[x].isAsked = true;
	return priorityQueueQuestions[x];
}

function pickAdaptively(){
	console.log(currentQuestion.score);
	if(currentQuestion.score == 1){
		for(var i=0; i<priorityQueueQuestions.length; i++){
			if(priorityQueueQuestions[i].difficulty - currentQuestion.difficulty>= 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
	else if(currentQuestion.score == 0.75){
		for(var i=0; i < priorityQueueQuestions.length; i++){
			if(currentQuestion.difficulty - priorityQueueQuestions[i].difficulty <= 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
	else{
		for(var i=0; i < priorityQueueQuestions.length; i++){
			if(currentQuestion.difficulty - priorityQueueQuestions[i].difficulty == 1 && priorityQueueQuestions[i].isAsked == false){
				priorityQueueQuestions[i].isAsked = true;
				return priorityQueueQuestions[i];
			}
		}
	}
}


function restartGame(){
	finish.style.display = 'none';
	for(var i=0; i < priorityQueueQuestions.length; i++){
		priorityQueueQuestions[i].isAsked = false;
		priorityQueueQuestions[i].score = 0;
	}
	if(!randomStrategy){
		currentQuestion.finishGame();
	}
	console.log("Zo hoog is hij nu " + this.height);
	//this.height = move(-this.height);
	this.height = moveTo(50);
	showNextQuestion();
}

function finishGame(){
	finish.style.display = 'none';
	// Verwijder de vraag onderaan.
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
	console.log("klaar!");
}

function getScore(){
	var sum = 0;
	for(var i=0; i < priorityQueueQuestions.length; i++){
			sum += priorityQueueQuestions[i].score;
	}
	return sum/priorityQueueQuestions.length * 10;
}

function allQuestionsAreAsked(){
	for(var i=0; i<priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				trial.molecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
			}
		}
		else if(textsQuestion[i].indexOf('Familiarity') > -1){
			var familiarity = textsQuestion[i].split(/~/);
			trial.familiarity = familiarity[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			trial.determineDifficulty();
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			console.log("You are going to make a new question now!");
			makeTrial(new Trial(game, group), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	popup.style.display = 'none';
	currentQuestion = decideQuestion(priorityQueueQuestions);
	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	var score = document.getElementById('score');
	gameDone.innerText = text;
	score.innerText = "Your score is " + getScore().toFixed(2);
	finish.style.display = 'block';
}

// This function should call the next question. It is now callin the checkTheAnswer function which checks if the molecule built is the correct molecule.
// After that it destroys the sprites and empties the currentMolecule list. This function needs to be split up.
function evaluateAnswer(){
	feedbackText = [];
	if(!gameIsFinished){

		if(checkTheAnswer()){
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				currentQuestion.score = 1;
				textAnswer.innerText = 'Great job!';
				popup.style.display = 'block';
				console.log((-1/priorityQueueQuestions.length)*50);
				this.height = move((-1/priorityQueueQuestions.length)*50);
			}
			else{
				currentQuestion.score = 1;
				showLastPopup('Great Job!');
				console.log((-1/priorityQueueQuestions.length)*50);
				this.height = move((-1/priorityQueueQuestions.length)*50);
			}
		}
		else{
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				textAnswer.innerText = 'Your answer is incorrect. ' + feedbackText;
				popup.style.display = 'block';
				currentQuestion.molecule = copyMolecule;
			}
			else{
				showLastPopup('Your answer is incorrect.');
			}
		}
		for(var i=0; i<currentQuestion.currentMolecule.length; i++){
			currentQuestion.currentMolecule[i].sprite.destroy();
		}
		currentQuestion.currentMolecule = [];
	}
}

// this function checks whether the currentMolecule has the right amount of atoms and the correct neighbours for each atom.
function checkTheAnswer(){
	copyMolecule = currentQuestion.molecule;
	if(currentQuestion.currentMolecule.length != currentQuestion.molecule.length){
		console.log('You do not have the right amount of atoms!');
		feedbackText = 'You do not have the right amount of atoms!';
		this.height = move((1/priorityQueueQuestions.length)*50);
		return false;
	}
	currentQuestion.score = 0.50;
	this.height = move((-0.5/priorityQueueQuestions.length)*50);
	console.log((0.5/priorityQueueQuestions.length)*50);
	for(var j=0; j< currentQuestion.molecule.length; j++)
		if(countNumberOfAtoms(currentQuestion.molecule, currentQuestion.molecule[j].value) != countNumberOfAtoms(currentQuestion.currentMolecule, currentQuestion.molecule[j].value)){
				console.log('You do not have the right types of atoms.');
				//console.log((-1/listOfQuestions.length)*100);
				feedbackText = 'You do not have the right types of atoms';
				//this.height = move((-1/listOfQuestions.length)*100);
				return false;
		}
	currentQuestion.score = 0.75;
	console.log("ik ga nu 0.75 dit doen");
	this.height = move((-0.75/priorityQueueQuestions.length)*50);
	console.log((0.75/priorityQueueQuestions.length)*50);
	return checkNeighbours();
}

// maak kopie van correct antwoord zodat je als je het antwoord fout hebt, nog verder kan gaan om het te verbeteren.
// check eerst of values of atomen gelijk zijn en kijk daarna naar de verbindingen ervan. Sorteer neighbours op alfabetische volgorde en check of de lijstjes
// gelijk zijn, als dat zo is, verwijder het atoom uit het correcte antwoord, zo niet dan return false

// you need to delete the neighbour if it is right otherwise you could find it again while it is checked already
// This function checks whether each atom of currentMolecule has the correct neighbours. (It is still not working.)
function checkNeighbours(){
	for(var k=0; k< currentQuestion.molecule.length; k++){
		for(var f=0; f< currentQuestion.currentMolecule.length; f++){
			if(currentQuestion.molecule[k].value == currentQuestion.currentMolecule[f].value){
				currentQuestion.molecule[k].neighbour.sort(function(a, b){
						return a.value < b.value;
				});
				for(var v=0; v<currentQuestion.molecule[k].neighbour.length; v++){
					console.log("neighbour: " + currentQuestion.molecule[k].neighbour[v].value);
				}
				currentQuestion.currentMolecule[f].neighbour.sort(function(a, b){
					return a.value < b.value;
				});
				if(!equalLists(currentQuestion.molecule[k].neighbour, currentQuestion.currentMolecule[f].neighbour)){
					feedbackText = 'You do not have the right connections between the atoms.';
					return false;
				}
				console.log(k);
				// moet deze splice nou wel of niet? Want zonder deze gaat het wel goed, nog over nadenken!!
			//	molecule.splice(k, 1);
			}
		}
	}
	return true;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function checks whether a specific atom has the right neighbours.
function checkNeighboursOfAtom(a, b){
	var boolean = false;
		for(var i=0; i < a.neighbour.length; i++){
				for(var j=0; j< b.neighbour.length; j++){
					if(countNumberOfAtoms(a.neighbour, a.neighbour[i].value) == countNumberOfAtoms(b.neighbour, a.neighbour[i].value)){
						boolean = true;
					}
					else{
						console.log("het ging hier fout" + countNumberOfAtoms(a.neighbour, a.neighbour[i].value) + ' ' + countNumberOfAtoms(b.neighbour, a.neighbour[i].value));
						return boolean = false;
					}
				}
		}
		return boolean;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
  //  if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element)){
		if(!gameIsFinished){
  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
  		var atomNew = new Atom(element, true, id, game);
  		currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
  	//}
		}
  }
	console.log("hallo");
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
	buttonsList.push(button);
  button.scale.setTo(0.4, 0.4);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			//console.log(atomB.id);
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
