
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src= "atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
	<div id="wrongAsnwer" class = "popup" >
		<div class = "popup-content">
			<p id = "textAnswer"></p>
			<!--<input type= "image" src = "images/tryAgain.png" id= "Okbutton" onclick ="showNextQuestion()">-->
			<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">
		</div	>
	</div>
	<div id= "gamedone" class = "popup">
		<div class = "popup-content">
			<p id = "finishText"></p>
			<p id = "score"></p>
			<input type= "image" src = "images/finish.png" id= "Okbutton" onclick ="finishGame()">
			<input type= "image" src = "images/restart.png" id= "Okbutton" onclick ="restartGame()">
		</div>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update});
var copyMolecule = [];
var currentQuestion = new Trial(game);
var id = 0;
var listOfQuestions = [];
var text = [];
var feedbackText = [];
var popup = document.getElementById('wrongAsnwer');
var finish = document.getElementById('gamedone');
var gameIsFinished = false;
var randomStrategy = false;

function preload() {
		game.load.image('CButton', 'images/CAtoomButton.png');
		game.load.image('OButton', 'images/OAtoomButton.png');
		game.load.image('HButton', 'images/HAtoom.png');
		game.load.image('delete', 'images/deleteP.png');
		game.load.image('C', 'images/CAtom.png');
		game.load.image('H', 'images/HAtom.png');
		game.load.image('O', 'images/OAtom.png');
		game.load.image('done', 'images/done.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion');
		game.load.text('questions', 'questions.txt');
}

function create() {
		readQuestion();
		console.log(game.world.centerX);
		currentQuestion = decideQuestion();

		if(currentQuestion != null){
			currentQuestion.showQuestion();
		}
		else{
			console.log("Klaar");

		}

		var atomValues = ['H', 'C', 'O'];
		var buttons = ['HButton', 'CButton', 'OButton'];
		var positionY = [150, 200, 250];
		game.stage.backgroundColor = "#ADD8E6";

		// Make buttons
		for(var i=0; i< atomValues.length; i++){
			console.log(buttons[i]);
			var buttonTest = new button(buttons[i],atomValues[i], 30, positionY[i]);
		}

		var doneButton = game.add.button(600, 525, 'done', evaluateAnswer, this);
		var deleteButton = game.add.image(10, 400, 'delete');

		deleteButton.scale.setTo(0.2, 0.2);
		doneButton.scale.setTo(0.5, 0.5);
}

function deleteAtom(){
	console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 35 && this.sprite.x > 10 && this.sprite.y > 350 && this.sprite.y < 430){
		console.log(this.sprite.x + " " + this.sprite.y);
		// je moet ook het atom verwijderen uit currentMolecule
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0){
			for(var i=0; i< listOfQuestions.length; i++){
				if(listOfQuestions[i].difficulty == 0){
					listOfQuestions[i].isAsked = true;
					return listOfQuestions[i];
				}
			}
		}
		return pickAdaptively();
	}
}

function pickRandomQuestion(){
	var x = Math.floor(Math.random() * (listOfQuestions.length - 0));
	while(listOfQuestions[x].isAsked == true){
		x = Math.floor(Math.random() * (listOfQuestions.length - 0));
	}
	listOfQuestions[x].isAsked = true;
	return listOfQuestions[x];
}

function pickAdaptively(){
	console.log(currentQuestion.score);
	if(currentQuestion.score == 1){
		for(var i=0; i<listOfQuestions.length; i++){
			if(listOfQuestions[i].difficulty - currentQuestion.difficulty== 1 && listOfQuestions[i].isAsked == false){
				listOfQuestions[i].isAsked = true;
				return listOfQuestions[i];
			}
		}
	}
	else if(currentQuestion.score == 0.75){
		for(var i=0; i < listOfQuestions.length; i++){
			if(currentQuestion.difficulty - listOfQuestions[i].difficulty <= 1 && listOfQuestions[i].isAsked == false){
				listOfQuestions[i].isAsked = true;
				return listOfQuestions[i];
			}
		}
	}
	else{
		for(var i=0; i < listOfQuestions.length; i++){
			if(currentQuestion.difficulty - listOfQuestions[i].difficulty == 1 && listOfQuestions[i].isAsked == false){
				listOfQuestions[i].isAsked = true;
				return listOfQuestions[i];
			}
		}
	}
}

function restartGame(){
	finish.style.display = 'none';
	for(var i=0; i < listOfQuestions.length; i++){
		listOfQuestions[i].isAsked = false;
		listOfQuestions[i].score = 0;
	}
	currentQuestion.finishGame();
	showNextQuestion();
}

function finishGame(){
	finish.style.display = 'none';
	// Verwijder de vraag onderaan.
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
	console.log("klaar!");
}

function getScore(){
	var sum = 0;
	for(var i=0; i < listOfQuestions.length; i++){
			sum += listOfQuestions[i].score;
	}
	return sum/listOfQuestions.length * 10;
}

function allQuestionsAreAsked(){
	for(var i=0; i<listOfQuestions.length; i++){
		if(listOfQuestions[i].isAsked == false){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				trial.molecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
			}
		}
		else if(textsQuestion[i].indexOf('Difficulty') > -1){
			var difficulty = textsQuestion[i].split(/~/);
			trial.difficulty = difficulty[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			console.log("You are going to make a new question now!");
			makeTrial(new Trial(game), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	popup.style.display = 'none';
	currentQuestion = decideQuestion(listOfQuestions);
	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	var score = document.getElementById('score');
	gameDone.innerText = text;
	score.innerText = "Your score is " + getScore().toFixed(2);
	finish.style.display = 'block';
}

// This function should call the next question. It is now callin the checkTheAnswer function which checks if the molecule built is the correct molecule.
// After that it destroys the sprites and empties the currentMolecule list. This function needs to be split up.
function evaluateAnswer(){
	feedbackText = [];
	if(!gameIsFinished){

		if(checkTheAnswer()){
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				currentQuestion.score = 1;
				textAnswer.innerText = 'Great job!';
				popup.style.display = 'block';
			}
			else{
				currentQuestion.score = 1;
				showLastPopup('Great Job!');
			}
		}
		else{
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				textAnswer.innerText = 'Your answer is incorrect. ' + feedbackText;
				popup.style.display = 'block';
				currentQuestion.molecule = copyMolecule;
			}
			else{
				showLastPopup('Your answer is incorrect.');
			}
		}
		for(var i=0; i<currentQuestion.currentMolecule.length; i++){
			currentQuestion.currentMolecule[i].sprite.destroy();
		}
		currentQuestion.currentMolecule = [];
	}
}

// this function checks whether the currentMolecule has the right amount of atoms and the correct neighbours for each atom.
function checkTheAnswer(){
	copyMolecule = currentQuestion.molecule;
	if(currentQuestion.currentMolecule.length != currentQuestion.molecule.length){
		console.log('You do not have the right amount of atoms!');
		feedbackText = 'You do not have the right amount of atoms!';
		return false;
	}
	currentQuestion.score = 0.50;
	for(var j=0; j< currentQuestion.molecule.length; j++)
		if(countNumberOfAtoms(currentQuestion.molecule, currentQuestion.molecule[j].value) != countNumberOfAtoms(currentQuestion.currentMolecule, currentQuestion.molecule[j].value)){
				console.log('You do not have the right types of atoms.');
				feedbackText = 'You do not have the right types of atoms';
				return false;
		}
	currentQuestion.score = 0.75;
	return checkNeighbours();
}

// maak kopie van correct antwoord zodat je als je het antwoord fout hebt, nog verder kan gaan om het te verbeteren.
// check eerst of values of atomen gelijk zijn en kijk daarna naar de verbindingen ervan. Sorteer neighbours op alfabetische volgorde en check of de lijstjes
// gelijk zijn, als dat zo is, verwijder het atoom uit het correcte antwoord, zo niet dan return false

// you need to delete the neighbour if it is right otherwise you could find it again while it is checked already
// This function checks whether each atom of currentMolecule has the correct neighbours. (It is still not working.)
function checkNeighbours(){
	for(var k=0; k< currentQuestion.molecule.length; k++){
		for(var f=0; f< currentQuestion.currentMolecule.length; f++){
			if(currentQuestion.molecule[k].value == currentQuestion.currentMolecule[f].value){
				currentQuestion.molecule[k].neighbour.sort(function(a, b){
						return a.value < b.value;
				});
				for(var v=0; v<currentQuestion.molecule[k].neighbour.length; v++){
					console.log("neighbour: " + currentQuestion.molecule[k].neighbour[v].value);
				}
				currentQuestion.currentMolecule[f].neighbour.sort(function(a, b){
					return a.value < b.value;
				});
				if(!equalLists(currentQuestion.molecule[k].neighbour, currentQuestion.currentMolecule[f].neighbour)){
					feedbackText = 'You do not have the right connections between the atoms.';
					return false;
				}
				console.log(k);
				// moet deze splice nou wel of niet? Want zonder deze gaat het wel goed, nog over nadenken!!
			//	molecule.splice(k, 1);
			}
		}
	}
	return true;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function checks whether a specific atom has the right neighbours.
function checkNeighboursOfAtom(a, b){
	var boolean = false;
		for(var i=0; i < a.neighbour.length; i++){
				for(var j=0; j< b.neighbour.length; j++){
					if(countNumberOfAtoms(a.neighbour, a.neighbour[i].value) == countNumberOfAtoms(b.neighbour, a.neighbour[i].value)){
						boolean = true;
					}
					else{
						console.log("het ging hier fout" + countNumberOfAtoms(a.neighbour, a.neighbour[i].value) + ' ' + countNumberOfAtoms(b.neighbour, a.neighbour[i].value));
						return boolean = false;
					}
				}
		}
		return boolean;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
  //  if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element)){
		if(!gameIsFinished){
  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
  		var atomNew = new Atom(element, true, id, game);
  		currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
  	//}
		}
  }
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
  button.scale.setTo(0.4, 0.4);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			//console.log(atomB.id);
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
