
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src="button.js"></script>
	<script type="text/javascript" src="atom.js"></script>
	<script type="text/javascript" src="trial.js"></script>
	<script type="text/javascript" src="delayText.js"></script>
	<script src="questions.txt"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
		<div id="startG" class= "firstpopup">
			<p id = "startTextofGame"></p>
			<input type= "image" src = "images/start.png" id= "startButton" onclick ="startG()">
		</div>
		<div id="wrongAnswer" class = "popup" >
			<div class = "popup-content">
				<p id = "textAnswer"></p>
				<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">
			</div	>
		</div>
		<div id= "gamedone" class = "popup">
			<div class = "popup-content">
				<p id = "finishText"></p>
				<p id = "score"></p>
				<input type= "image" src = "images/finish.png" id= "Okbutton" onclick ="finishGame()">
			<!--<input type= "image" src = "images/restart.png" id= "Okbutton" onclick ="restartGame()"> -->
			</div>
		</div>
		<div class = "progressText">
			<div class = "textProgresscontent">
				<p id="textprogress" style="font: bold 18px times new roman; color: green;"> Current Salary</p>
			</div>
		</div>

		<div class = "progress">
			<div id="myProgress">
		  	<div id="myBar"></div>
			</div>
		</div>

		<div class = "amountSalary">
			<div class = "SalaryContent">
				<p id="salarytext" style="font: 15px times new roman; color: green;"></p>
			</div>
		</div>

	<div id= "missionTextPopup" class = "missionPopup">
		<div class = "mission-content">
			<p id = "missionText"></p>
		</div>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update, render: render});

var popup = document.getElementById('wrongAnswer');
var finish = document.getElementById('gamedone');
var firstpopup = document.getElementById('startG');
var missionpopup = document.getElementById('missionTextPopup');
var bar = document.getElementById("myBar");

bar.style.height = "90%";

var currentQuestion = new Trial(game);
var id = 0;
var height = 90;

var listOfQuestions = [];
var priorityQueueQuestions = [];
var text = [];
var feedbackText = [];
var buttonsList = [];

var buttons = ['HButton', 'CButton', 'OButton', 'QButton', 'FButton', 'IButton'];
var positionY = [100, 150, 200, 250, 300, 350];
var gameIsFinished = false;
var randomStrategy = false;

var floor;
var doneButton;
var deleteButton;

var totalScore = 10; // van 0 tot 100. 0 is niks 100 is alles.

function preload() {
		game.load.image('CButton', 'images/CAtoomButtonBrown.png');
		game.load.image('OButton', 'images/OAtomButtonBrown.png');
		game.load.image('HButton', 'images/HAtoomButtonBrown.png');
		game.load.image("FButton", 'images/FAtomButton.png')
		game.load.image("QButton", 'images/BrAtomButton.png')
		game.load.image("IButton", 'images/IAtomButton.png')
		game.load.image('delete', 'images/garbage.png');
		game.load.image('C', 'images/CAtom1.png');
		game.load.image('H', 'images/HAtom.png');
		game.load.image('O', 'images/OAtom.png');
		game.load.image('I', 'images/IAtom.png');
		game.load.image('Q', 'images/BrAtom.png');
		game.load.image('F', 'images/FAtom.png');
		game.load.image('done', 'images/doneButton.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion');
		game.load.image('start', 'images/start.png');
		game.load.text('questions', 'questions.txt');
}

function create(){
	var graphics1 = game.add.graphics(0, 0);
	var graphics2 = game.add.graphics(0, 0);
	var whiterect = game.add.graphics(0, 0);

	graphics1.beginFill(0xffdd99);
	graphics2.beginFill(0xAAAAAA);
	whiterect.beginFill(0xe6f2ff);

	graphics1.drawRect(10, 10, 80, 480); //3

	graphics1.drawRect(10, 500, 80, 90); //4

	graphics1.drawRect(100, 500, 575, 90); //5

	graphics1.drawRect(685, 500, 105, 90); //6

	graphics1.drawRect(685, 10, 105, 480); //7

	whiterect.drawRect(100,10, 575, 480); //2

	makeStartPopup();
	readQuestion();
	makePriorityQueue();
	currentQuestion = decideQuestion();

	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		console.log("Klaar");
	}
	var atomValues = ['H', 'C', 'O', 'Q', 'F', 'I'];
	game.stage.backgroundColor = "#DBB782";
	// Make buttons
	currentQuestion.makeButtons();
	doneButton = game.add.button(700, 520, 'done', evaluateAnswer3, this);

	deleteButton = game.add.image(12, 500, 'delete');

	deleteButton.scale.setTo(0.4, 0.4);
	doneButton.scale.setTo(0.50, 0.50);
	doneButton.visible = false;
	deleteButton.visible = false;

	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = false;
	}
}

function decideQuestion(){
	if(randomStrategy){
		return pickRandomQuestion();
	}
	else{
		if(currentQuestion.molecule.length == 0 && !currentQuestion.alreadyAdded){
			priorityQueueQuestions[0].isAsked = true;
			console.log(priorityQueueQuestions[0].repeat);
			return priorityQueueQuestions[0];
		}
		return decideAdaptively();
	}
}

function render () {
    game.debug.geom(floor,'#ffffff');
}

function makeStartPopup(){
	var startTextofGame = document.getElementById('startTextofGame');
	startTextofGame.innerText =
		"You are working in a laboratory. " +
		"When you click on Start you are asked to complete some important missions! " +
		"Try to complete as many mission as you can and become rich! The bar on the right gives you an indication of how much money you are earning. " +
		"We need you, do not disappoint us."
}

function startG(){
	firstpopup.style.display = 'none';
	for(var i=0; i<buttonsList.length; i++){
		buttonsList[i].visible = true;
	}
	deleteButton.visible = true;
	doneButton.visible = true;
	console.log('start');
}

function determineOveralDifficulty(){
	var sum = 0;
	for(var i=0; i < listOfQuestions.length; i++){
		sum = sum + listOfQuestions[i].difficulty;
		//console.log(listOfQuestions[i].currentQuestionText +  ", " + listOfQuestions[i].difficulty);
	}
	return sum;
}

function updateBar() {
	var SPEED = 1;
	var MINIMUM_EPSILON = 1;

	var elem = document.getElementById("myBar");
	var goalHeight = 100 - this.totalScore;
	var id = setInterval(frame, 20);

	function frame() {
		var currentHeight = parseInt(elem.style.height);
		var epsilon = goalHeight - currentHeight;
		if (Math.abs(epsilon) < MINIMUM_EPSILON)
			clearInterval(id);
		var newHeight = currentHeight + SPEED * Math.sign(epsilon)
		elem.style.height = newHeight + '%';
	}
}

function updateBarColor(){
	var elem = document.getElementById("myProgress");
	if(totalScore <= 10){
		elem.style.backgroundColor = "red";
	}
	else if(totalScore <= 30 && totalScore > 10){
		elem.style.backgroundColor = "orange";
	}
	else if(totalScore <= 50 && totalScore > 30){
		elem.style.backgroundColor = "yellow";
	}
	else if(totalScore <= 65 && totalScore > 50){
		elem.style.backgroundColor = "#ccff66";
	}
	else{
		elem.style.backgroundColor = "#669900";
	}
}

function updateSalary(){
	var salarytext = document.getElementById('salarytext');
	var roundScore = Math.round(totalScore);
	if(roundScore == 1){
		salarytext.innerText = "Your salary is " + 1 + " euro.";
	}
	else{
		salarytext.innerText = "Your salary is " + roundScore + " euros.";
	}
}

function deleteAtom(){
	console.log(this.sprite.x + " " + this.sprite.y);
	if(this.sprite.x < 35 && this.sprite.x > 5 && this.sprite.y > 440 && this.sprite.y < 530){
		console.log(this.sprite.x + " " + this.sprite.y);
		this.sprite.destroy();
		removeAtom(this);
		}
}

function removeAtom(atom){
	for(var i=0; i < currentQuestion.currentMolecule.length; i++){
		if(currentQuestion.currentMolecule[i].id == atom.id){
			console.log("Dit atoom is verwijderd " + atom.value);
			currentQuestion.currentMolecule.splice(i, 1);
		}
	}
}

function makePriorityQueue(){
	var priority = [];
	for(var i=0; i<listOfQuestions.length; i++){
		priority.push(listOfQuestions[i].difficulty);
	}
	priority = priority.sort(function(a,b){
		return (+a) - (+b);
	});
	for(var i=0; i<priority.length; i++){
		for(var j=0; j<listOfQuestions.length; j++){
			if(priority[i] == listOfQuestions[j].difficulty && !priorityQueueQuestions.includes(listOfQuestions[j])){
				this.priorityQueueQuestions.push(listOfQuestions[j]);
				console.log(listOfQuestions[j].currentQuestionText + " ");
			}
		}
	}
}

function pickRandomQuestion(){
	var x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	while(priorityQueueQuestions[x].isAsked == true){
		x = Math.floor(Math.random() * (priorityQueueQuestions.length - 0));
	}
	priorityQueueQuestions[x].isAsked = true;
	return priorityQueueQuestions[x];
}

function decideAdaptively(){
	for(var i=0; i< priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false || priorityQueueQuestions[i].repeat >= 1){
			console.log(priorityQueueQuestions.repeat +  ", deze ga ik doen: " + priorityQueueQuestions.length);
			priorityQueueQuestions[i].isAsked = true;
			if(priorityQueueQuestions[i].repeat > 0){
				console.log(priorityQueueQuestions[i].repeat);
				priorityQueueQuestions[i].repeat -= 1;
				console.log(priorityQueueQuestions[i].repeat);
			}
			else{
				priorityQueueQuestions[i].repeat = 0;

			}
			return priorityQueueQuestions[i];
		}
	}
}

function restartGame(){
	for(var i=0; i < priorityQueueQuestions.length; i++){
		priorityQueueQuestions[i].isAsked = false;
		priorityQueueQuestions[i].repeat = 0;
		priorityQueueQuestions[i].score = 0;
	}
	if(!randomStrategy){
		currentQuestion.finishGame();
	}
	totalScore = 10;
	updateBar();
	updateSalary();
	showNextQuestion();
}

function finishGame(){
	finish.style.display = 'none';
	// Verwijder de vraag onderaan
	if(text != undefined){
		game.world.remove(text);
		currentQuestion.finishGame();
	}
	gameIsFinished = true;
}

function getScore(){
	var sum = 0;
	for(var i=0; i < priorityQueueQuestions.length; i++){
			sum += priorityQueueQuestions[i].score;
	}
	return sum/priorityQueueQuestions.length * 10;
}

function allQuestionsAreAsked(){
	for(var i=0; i<priorityQueueQuestions.length; i++){
		if(priorityQueueQuestions[i].isAsked == false){
			return false;
		}
	}
	return true;
}

function makeTrial(trial, index, textsQuestion){
	for(var i= index; i< textsQuestion.length; i++){
		if(textsQuestion[i].indexOf('Question') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			trial.currentQuestionText = newQuestion[1];
		}
		else if(textsQuestion[i].indexOf('Mole') > -1){
			var newQuestion = textsQuestion[i].split(/~/);
			var atomsOfMolecule = newQuestion[1];
			for(var j=0; j < atomsOfMolecule.length; j++){
				trial.molecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
				trial.copyMolecule.push(new Atom(atomsOfMolecule[j], false, id+j, game));
			}
		}
		else if(textsQuestion[i].indexOf('Familiarity') > -1){
			var familiarity = textsQuestion[i].split(/~/);
			trial.familiarity = familiarity[1];
		}
		else if(textsQuestion[i].indexOf("Binding") > -1){
			for(var m=i+1; m < textsQuestion[i+1].length+i+1; m++){
				for(var k=0; k< textsQuestion[i+1].length; k++){
					var value = textsQuestion[m];
					if(value[k] == 1){
						trial.molecule[k].addConnection(trial.molecule[m-(i+1)]);
						trial.copyMolecule[k].addConnection(trial.copyMolecule[m-(i+1)]);
					}
				}
			}
			this.listOfQuestions.push(trial);
			trial.determineDifficulty();
			return;
		}
	}
	return;
}

function readQuestion(){
  var textQuestion = game.cache.getText('questions');
	console.log(textQuestion);
  textsQuestion = textQuestion.split('\n');
	for(var i=0; i< textsQuestion.length; i++){
		if(textsQuestion[i] == ""){
			console.log("You are going to make a new question now!");
			makeTrial(new Trial(game), i+1, textsQuestion);
		}
	}
}

function showNextQuestion(){
	var textAnswer = document.getElementById('textAnswer');
	textAnswer.style.color = "black";
	popup.style.display = 'none';
	currentQuestion = decideQuestion(priorityQueueQuestions);
	if(currentQuestion != null){
		currentQuestion.showQuestion();
	}
	else{
		return;
	}
}

function showLastPopup(text){
	var gameDone = document.getElementById('finishText');
	var score = document.getElementById('score');
	gameDone.innerText = text;
	score.innerText = "Your score is " + getScore().toFixed(2);
	finish.style.display = 'block';
}

function evaluateAnswer3(){
	var rightAmount = currentQuestion.checkAmountOfAtoms();
	var rightAmountUnique = currentQuestion.checkUniqueAtoms();
	var rightType = currentQuestion.checkAmountOfTypeOfAtoms();
	var rightConnections = currentQuestion.checkConnections2();
	console.log(rightAmount, rightType, rightAmountUnique, rightConnections);
	determineScore(rightType, rightConnections, rightAmount, rightAmountUnique);
}

function determineScore(rightType, rightConnections, rightAmount, rightAmountUnique){
	if(!allQuestionsAreAsked()){
		if(rightType && rightConnections && rightAmount && rightAmountUnique){
			var textAnswer = document.getElementById('textAnswer');
			currentQuestion.score = 1;
			totalScore += convertScoreChange(1);
			textAnswer.innerText = 'Great job!';
			popup.style.display = 'block';
		}
		else{
			var textAnswer = document.getElementById('textAnswer');
			textAnswer.style.color = "red";
			textAnswer.innerText = 'Your answer is incorrect. ' + feedbackText;
			totalScore += convertScoreChange(-1);
			popup.style.display = 'block';
		}
		for(var i=0; i<currentQuestion.currentMolecule.length; i++){
			currentQuestion.currentMolecule[i].sprite.destroy();
		}
		currentQuestion.currentMolecule = [];
		totalScore = Math.max(0,totalScore);
		updateBar();
		updateBarColor();
		updateSalary();
	}
	else{
		showLastPopup('Great Job!');

	}
}

// This function should call the next question. It is now callin the checkTheAnswer function which checks if the molecule built is the correct molecule.
// After that it destroys the sprites and empties the currentMolecule list. This function needs to be split up.
function evaluateAnswer(){
	printMolecule();
	feedbackText = [];
	if(!gameIsFinished){
		if(checkTheAnswer()){
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				currentQuestion.score = 1;
				textAnswer.innerText = 'Great job!';
				popup.style.display = 'block';
			}
			else{
				currentQuestion.score = 1;
				showLastPopup('Great Job!');
			}
			totalScore += convertScoreChange(1);
		}
		else{
			if(!allQuestionsAreAsked()){
				var textAnswer = document.getElementById('textAnswer');
				textAnswer.style.color = "red";
				textAnswer.innerText = 'Your answer is incorrect. ' + feedbackText;
				popup.style.display = 'block';
			}
			else{
				showLastPopup('Your answer is incorrect.');
			}
		}
		for(var i=0; i<currentQuestion.currentMolecule.length; i++){
			currentQuestion.currentMolecule[i].sprite.destroy();
		}
		currentQuestion.currentMolecule = [];
		addWrongQuestion();
	}
	totalScore = Math.max(0,totalScore);
	updateBar();
	updateBarColor();
	updateSalary();
}

function addWrongQuestion(){
	var currentLength = priorityQueueQuestions.length;
	for(var i=0; i < currentQuestion.repeat; i++){
		if(!currentQuestion.alreadyAdded){
			priorityQueueQuestions.push(currentQuestion);
			console.log(currentQuestion);
		}
	}
	if(currentLength != priorityQueueQuestions.length){
		currentQuestion.alreadyAdded = true;
		console.log("deze ga ik niet adden");
	}
	console.log(priorityQueueQuestions.length);
}

function printMolecule(){
	for(var i=0; i<currentQuestion.currentMolecule.length; i++){
		console.log("Dit is Atom nummer " +  i + ", " + currentQuestion.currentMolecule[i].value + ", " + currentQuestion.currentMolecule[i].id);
		console.log(currentQuestion.currentMolecule[i]);
	}
}

// this function checks whether the currentMolecule has the right amount of atoms and the correct neighbours for each atom.
function checkTheAnswer(){
	if(currentQuestion.currentMolecule.length != currentQuestion.molecule.length){
		console.log('You do not have the right amount of atoms!');
		feedbackText = 'You do not have the right amount of atoms!';
		//this.height = move(determineShiftInBar(1.0));
		totalScore += convertScoreChange(-1);
		if(currentQuestion.repeat == 0 && !currentQuestion.alreadyAdded){
			currentQuestion.repeat = 2;
		}
		//console.log(this.height);
		return false;
	}
	else{
		for(var j=0; j< currentQuestion.molecule.length; j++){
			if(countNumberOfAtoms(currentQuestion.molecule, currentQuestion.molecule[j].value) != countNumberOfAtoms(currentQuestion.currentMolecule, currentQuestion.molecule[j].value)){
					currentQuestion.score = 0.50;
					// this.height = move(determineShiftInBar(-0.5));
					// console.log(determineShiftInBar(-0.5));
					totalScore += convertScoreChange(0.5);
					feedbackText = 'You do not have the right types of atoms';
					if(currentQuestion.repeat == 0 && !currentQuestion.alreadyAdded){
						currentQuestion.repeat = 3;
					}
					return false;
			}
		}
		currentQuestion.score = 0.75;
		// this.height = move(determineShiftInBar(-0.75));
		// console.log(determineShiftInBar(-0.75));

	 	var c = checkNeighbours();
		if (!c)
			totalScore += convertScoreChange(0.75);
		return  c;
	}
}

function convertScoreChange(answerScore) {
	var totalDifficulty = determineOveralDifficulty();
	return answerScore * 90 * currentQuestion.difficulty / totalDifficulty;
}

// maak kopie van correct antwoord zodat je als je het antwoord fout hebt, nog verder kan gaan om het te verbeteren.
// check eerst of values of atomen gelijk zijn en kijk daarna naar de verbindingen ervan. Sorteer neighbours op alfabetische volgorde en check of de lijstjes
// gelijk zijn, als dat zo is, verwijder het atoom uit het correcte antwoord, zo niet dan return false

// you need to delete the neighbour if it is right otherwise you could find it again while it is checked already
// This function checks whether each atom of currentMolecule has the correct neighbours. (It is still not working.)
function checkNeighbours(){
	for(var k=0; k< currentQuestion.molecule.length; k++){
		for(var f=0; f< currentQuestion.currentMolecule.length; f++){
			if(currentQuestion.molecule[k].value == currentQuestion.currentMolecule[f].value){
				currentQuestion.molecule[k].neighbour.sort(function(a, b){
						return a.value < b.value;
				});
				for(var v=0; v<currentQuestion.molecule[k].neighbour.length; v++){
					console.log("neighbour: " + currentQuestion.molecule[k].neighbour[v].value);
				}
				currentQuestion.currentMolecule[f].neighbour.sort(function(a, b){
					return a.value < b.value;
				});
				if(!equalLists(currentQuestion.molecule[k].neighbour, currentQuestion.currentMolecule[f].neighbour)){
					feedbackText = 'You do not have the right connections between the atoms.';
					currentQuestion.repeat = 1;
					return false;
				}
				console.log(k);
				// moet deze splice nou wel of niet? Want zonder deze gaat het wel goed, nog over nadenken!!
				// currentQuestion.molecule.splice(k, 1);
			}
		}
	}
	currentQuestion.molecule = currentQuestion.copyMolecule;
	return true;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function checks whether a specific atom has the right neighbours.
function checkNeighboursOfAtom(a, b){
	var boolean = false;
		for(var i=0; i < a.neighbour.length; i++){
				for(var j=0; j< b.neighbour.length; j++){
					if(countNumberOfAtoms(a.neighbour, a.neighbour[i].value) == countNumberOfAtoms(b.neighbour, a.neighbour[i].value)){
						boolean = true;
					}
					else{
						console.log("het ging hier fout" + countNumberOfAtoms(a.neighbour, a.neighbour[i].value) + ' ' + countNumberOfAtoms(b.neighbour, a.neighbour[i].value));
						return boolean = false;
					}
				}
		}
		return boolean;
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}
//Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
  //  if(countNumberOfAtoms(currentQuestion.currentMolecule, element) != countNumberOfAtoms(currentQuestion.molecule, element)){
		if(!gameIsFinished){
  		console.log(countNumberOfAtoms(currentQuestion.molecule, element));
  		var atomNew = new Atom(element, true, id, game);
  		currentQuestion.currentMolecule.push(atomNew);
			id = id+1;
  	//}
		}
  }
  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
	game.world.bringToTop(button);
	buttonsList.push(button);
  button.scale.setTo(0.3, 0.3);
}

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			return true;
		}
	}
	return false;
}

// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 40){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 40){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentQuestion != null && !gameIsFinished){
		if(currentQuestion.currentMolecule != null){
			snap(currentQuestion.currentMolecule);
		}
	}
}

</script>
</body>
</html>
