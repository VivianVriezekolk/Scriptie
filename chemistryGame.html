
<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Test dragging</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
	<script type="text/javascript" src= "atom.js"></script>
	<script type="text/javascript" src= "button.js"></script>
	<link rel="stylesheet" href="layout.css">
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
	<div id="wrongAsnwer" class = "popup" >
		<div class = "popup-content">
	<p id = "textAnswer"></p>
	<!--<input type= "image" src = "images/tryAgain.png" id= "Okbutton" onclick ="showNextQuestion()">-->
	<input type= "image" src = "images/nextQuestion" id= "Okbutton" onclick ="showNextQuestion()">
</div	>
	</div>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'phaser-example', { preload: preload, create: create, update: update});
var molecule = [];
var copyMolecule = [];
var currentMolecule = [];
var id = 0;
var popup = document.getElementById('wrongAsnwer');

function preload() {
		game.load.image('CButton', 'images/CAtoomButton.png');
		game.load.image('OButton', 'images/OAtoomButton.png');
		game.load.image('HButton', 'images/HAtoom.png');
		game.load.image('C', 'images/CAtom.png');
		game.load.image('H', 'images/HAtom.png');
		game.load.image('O', 'images/OAtom.png');
		game.load.image('done', 'images/done.png');
		game.load.image('tryAgain', 'images/tryAgain.png');
		game.load.image('nextQuestion', 'images/nextQuestion');
}

function create() {
		var atomValues = ['H', 'C', 'O'];
		var buttons = ['HButton', 'CButton', 'OButton'];
		var positionY = [150, 200, 250];
		game.stage.backgroundColor = "#ADD8E6";

		for(var i=0; i< atomValues.length; i++){
			console.log(buttons[i]);
			var buttonTest = new button(buttons[i],atomValues[i], 10, positionY[i]);
		}

		//var buttonC = game.add.button(10, 200, 'CButton', actionOnClick, this);
		//var buttonH = game.add.button(10, 150, 'HButton', actionOnClickA, this);
		//var buttonO = game.add.button(10, 250, 'OButton', actionOnClickO, this);
		//buttonC.scale.setTo(0.4, 0.4);
		//buttonH.scale.setTo(0.4, 0.4);
		//buttonO.scale.setTo(0.4, 0.4);

		// makes a doneButton
		var doneButton = game.add.button(600, 525, 'done', nextQuestion, this);
		doneButton.scale.setTo(0.5, 0.5);

		// make molecule for first question
		var atoms = [];
		var atomO = new atom('O', false, 0);
		var atomH = new atom('H', false, 1);
		var atomH2 = new atom('H',false, 2);

		atomH.addConnection(atomO);

		atomO.addConnection(atomH);
		atomO.addConnection(atomH2);

		atomH2.addConnection(atomO);

		atoms.push(atomH);
		atoms.push(atomO);
		atoms.push(atomH2);
		//printNeighbours(atomH2);
		for (var i=0; i< atoms.length; i++){
			molecule.push(atoms[i]);
		}
		var question1 = new question(molecule, 'You need to make water now!');
		showQuestion(question1);
}

function showNextQuestion(){
	popup.style.display = 'none';
}

// This function should call the next question. It is now callin the checkTheAnswer function which checks if the molecule built is the correct molecule.
// After that it destroys the sprites and empties the currentMolecule list. This function needs to be split up.
function nextQuestion(){
		if(checkTheAnswer()){
			var textAnswer = document.getElementById('textAnswer');
			textAnswer.innerText = 'Great job!';
			popup.style.display = 'block';
		}
		else{
			var textAnswer = document.getElementById('textAnswer');
			textAnswer.innerText = 'You did not make the correct molecule';
			popup.style.display = 'block';
			console.log('You did not make the correct molecule.');
			molecule = copyMolecule;
			console.log(molecule);
		}
		for(var i=0; i<currentMolecule.length; i++){
			currentMolecule[i].sprite.destroy();
		}
		currentMolecule = [];
}

// this function prints values of the neighbours of three atoms.
function printNeighbours2(){
	console.log(currentMolecule[0].value + 'neighbours are: ');
	printNeighbours(currentMolecule[0]);
	console.log(currentMolecule[1].value + 'neighbours are: ');
	printNeighbours(currentMolecule[1]);
	console.log(currentMolecule[2].value + 'neighbours are: ');
	printNeighbours(currentMolecule[2]);
}

// this function checks whether the currentMolecule has the right amount of atoms and the correct neighbours for each atom.
function checkTheAnswer(){
	copyMolecule = molecule;
	if(currentMolecule.length != molecule.length){
		console.log('You do not have the right amount of atoms!');
		return false;
	}
	console.log('You have the right amount of atoms!');
	for(var j=0; j< molecule.length; j++)
		if(countNumberOfAtoms(molecule, molecule[j].value) != countNumberOfAtoms(currentMolecule, molecule[j].value)){
				console.log('You do not have the right types of atoms');
				return false;
		}
	return checkNeighbours();
}

// maak kopie van correct antwoord zodat je als je het antwoord fout hebt, nog verder kan gaan om het te verbeteren.
// check eerst of values of atomen gelijk zijn en kijk daarna naar de verbindingen ervan. Sorteer neighbours op alfabetische volgorde en check of de lijstjes
// gelijk zijn, als dat zo is, verwijder het atoom uit het correcte antwoord, zo niet dan return false

// you need to delete the neighbour if it is right otherwise you could find it again while it is checked already
// This function checks whether each atom of currentMolecule has the correct neighbours. (It is still not working.)
function checkNeighbours(){
	for(var k=0; k< molecule.length; k++){
		console.log(molecule.length);
		for(var f=0; f< currentMolecule.length; f++){
			if(molecule[k].value == currentMolecule[f].value){
				molecule[k].neighbour.sort(function(a, b){
						return a.value < b.value;
				});
				for(var v=0; v<molecule[k].neighbour.length; v++){
					console.log("neighbour: " + molecule[k].neighbour[v].value);
				}
				currentMolecule[f].neighbour.sort(function(a, b){
					return a.value < b.value;
				});
				if(!equalLists(molecule[k].neighbour, currentMolecule[f].neighbour)){
					console.log('Je hebt niet de goede verbindingen');
					return false;
				}
				molecule.splice(k, 1);
			}
		}
	}
	return true;
}

// This function checks whether two lists are the same.
function equalLists(neighbourMolecule, neighbourCurrentMolecule){
	if(neighbourMolecule.length != neighbourCurrentMolecule.length){
		return false;
	}
	for(var i=0; i < neighbourMolecule.length; i++){
		if(neighbourMolecule[i].value != neighbourCurrentMolecule[i].value){
			return false;
		}
	}
	return true;
}

// This function checks whether a specific atom has the right neighbours.
function checkNeighboursOfAtom(a, b){
	var boolean = false;
		for(var i=0; i < a.neighbour.length; i++){
				for(var j=0; j< b.neighbour.length; j++){
					if(countNumberOfAtoms(a.neighbour, a.neighbour[i].value) == countNumberOfAtoms(b.neighbour, a.neighbour[i].value)){
						boolean = true;
					}
					else{
						console.log("het ging hier fout" + countNumberOfAtoms(a.neighbour, a.neighbour[i].value) + ' ' + countNumberOfAtoms(b.neighbour, a.neighbour[i].value));
						return boolean = false;
					}
				}
		}
		return boolean;
}

// show a particular question on screen.
function showQuestion(question){
	var style = { font: "15px Arial", fill: "#000000", align: "center" };
	var text = game.add.text(game.world.centerX, 550,  question.text, style);
	text.anchor.set(0.5);
}

// This function counts the number of atoms with a specific value in a molecule
function countNumberOfAtoms(SpecMolecule, valueOfSpecificAtom){
	var count = 0;
	for(var i=0; i< SpecMolecule.length; i++){
		if(SpecMolecule[i].value == valueOfSpecificAtom){
			count = count + 1;
		}
	}
	return count;
}

// object of an atom with a certain value and neighbours.
function atom(value, currentAtom, id) {
    this.value = value
		this.neighbour = [];
		this.id = id;
		if(currentAtom){
			this.sprite = game.add.sprite(5, 100, value);
		}

		// this function adds a connection between atoms.
		this.addConnection = function(snappedAtom){
				if(!atomsAreSnapped(this, snappedAtom)){
					console.log(this.value + " is connected to " + snappedAtom.value);
					this.neighbour.push(snappedAtom);
				}
			}

		// this function removes a connection between atoms.
		this.removeConnection = function(lostAtom){
			for(var i=0; i<this.neighbour.length; i++){
				if(this.neighbour[i].value == lostAtom.value){
					console.log(lostAtom.value + " is removed from " + this.value);
					this.neighbour.splice(i, 1);
				}
			}
		}
}

// Object button
function button(buttonName, element, X, Y){
  this.element = element;
  this.buttonName = buttonName;

  this.actionOnClick = function(){
    console.log("You clicked on me!!");
    if(countNumberOfAtoms(currentMolecule, element) != countNumberOfAtoms(molecule, element)){
  		console.log(countNumberOfAtoms(molecule, element));
  		var atomNew = new atom(element, true, id);
  		atomNew.sprite.inputEnabled = true;
  		atomNew.sprite.input.enableDrag();
  		atomNew.sprite.input.enableDrag(true);
  		atomNew.sprite.input.enableSnap(32, 32, false, true);
  		currentMolecule.push(atomNew);
			id = id+1;
  	}
  }

  var button = game.add.button(X, Y, buttonName, this.actionOnClick, this);
  button.scale.setTo(0.4, 0.4);
}

// object of a question with a particular molecule that has to be made and the mission text
function question(molecule, text){
	this.molecule = molecule;
	this.text = text;
}

//The button calls this function and adds more C atoms. There should be a limit and the button needs to be nicer.
// function actionOnClick(){
// 	if(countNumberOfAtoms(currentMolecule,'C') != countNumberOfAtoms(molecule, 'C')){
// 		var atomNew = new atom('C', true, id);
// 		atomNew.sprite.inputEnabled = true;
// 		atomNew.sprite.input.enableDrag();
// 		atomNew.sprite.input.enableDrag(true);
// 		atomNew.sprite.input.enableSnap(32, 32, false, true);
// 		id = id + 1;
// 		// To scale the sprite.
// 		// var scaleX = 0.02;
// 		// var scaleY = 0.02;
// 		// atomNew.sprite.scale.set(scaleX , scaleY);
//
// 		currentMolecule.push(atomNew);
// 	}
// }
//
// //The button calls this function and adds more C atoms.
// function actionOnClickA(){
// 	if(countNumberOfAtoms(currentMolecule,'H') != countNumberOfAtoms(molecule, 'H')){
// 		var atomNew = new atom('H', true, id);
// 		atomNew.sprite.inputEnabled = true;
// 		atomNew.sprite.input.enableDrag();
// 		atomNew.sprite.input.enableDrag(true);
// 		atomNew.sprite.input.enableSnap(32, 32, false, true);
// 		id = id + 1;
// 		currentMolecule.push(atomNew);
// 		}
// }
// //The button calls this function and adds more O atoms.
// function actionOnClickO(){
//  if(countNumberOfAtoms(currentMolecule,'O') != countNumberOfAtoms(molecule, 'O')){
// 		var atomNew = new atom('O', true, id);
// 		atomNew.sprite.inputEnabled = true;
// 		atomNew.sprite.input.enableDrag();
// 		atomNew.sprite.input.enableDrag(true);
// 		atomNew.sprite.input.enableSnap(32, 32, false, true);
// 		currentMolecule.push(atomNew);
// 		id = id + 1;
// 		}
// }

function atomsAreSnapped(atomA, atomB){
	for(var i=0; i< atomA.neighbour.length; i++){
		if(atomA.neighbour[i].id == atomB.id){
			console.log(atomB.id);
			return true;
		}
	}
	return false;
}

// This function checks whether two molecules are close and snaps them together.
// function snapToAtom(currentMolecule){
// 	var snapTo;
// 	for(var j = 0; j< currentMolecule.length; j++){
// 		var nearAny = false;
// 		for(var k = 0; k < currentMolecule.length; k++){
// 			if(k != j){
// 				var distance = game.physics.arcade.distanceBetween(currentMolecule[j].sprite, currentMolecule[k].sprite);
// 				if(distance < 64) {
// 						nearAny = true;
// 						snapTo = k;
// 				}
// 			}
// 		}
// 		// Better solution than an if statement
// 		if(!atomsAreSnapped(currentMolecule[j], currentMolecule[snapTo])){
// 			if(nearAny){
// 				currentMolecule[j].sprite.input.enableSnap(32, 32, nearAny, true);
// 				console.log(currentMolecule[j].value + ' adds ' + currentMolecule[snapTo].value);
// 				currentMolecule[j].addConnection(currentMolecule[snapTo]);
// 				currentMolecule[snapTo].addConnection(currentMolecule[j]);
// 				//makeConnection(currentMolecule[snapTo], currentMolecule[j]);
// 			}
// 		}
// 		else{
// 			if(currentMolecule.length > 1 && !nearAny){
// 				console.log('-' + currentMolecule[j].value + ' removes ' + currentMolecule[snapTo].value);
// 				currentMolecule[j].removeConnection(currentMolecule[snapTo]);
// 				currentMolecule[snapTo].removeConnection(currentMolecule[j]);
// 			}
// 		}
// 	}
// }


// this functions adds atoms that are close together
function snap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		for(var j=0; j< currentMolecule.length; j++){
			if(i != j){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[j].sprite);
				if(distance < 64){
					currentMolecule[i].addConnection(currentMolecule[j]);
					currentMolecule[i].sprite.input.enableSnap(32, 32, true, true);
				}
			}
		}
	}
	undoneSnap(currentMolecule);
}

// This function checks whether some atoms have neighbours that need to be 'unsnapped' and unsnaps them.
function undoneSnap(currentMolecule){
	for(var i=0; i< currentMolecule.length; i++){
		var atom = currentMolecule[i]
		for(var j=0; j<currentMolecule[i].neighbour.length; j++){
				var distance = game.physics.arcade.distanceBetween(currentMolecule[i].sprite, currentMolecule[i].neighbour[j].sprite);
				if(distance > 64){
					currentMolecule[i].removeConnection(currentMolecule[i].neighbour[j]);
				}
		}
		if(currentMolecule[i].neighbour.length == 0){
			currentMolecule[i].sprite.input.enableSnap(32, 32, false, true);
		}
	}
}

// This function prints all values of the neighbours of atom a.
function printNeighbours(a){
	for(var i=0; i< a.neighbour.length; i++){
		console.log(a.neighbour[i].value);
	}
}

// This update function checks whether two molecules are close to each other and then snaps.
function update() {
	if(currentMolecule != null){
		snap(currentMolecule);
	}
}

</script>
</body>
</html>
